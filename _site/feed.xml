<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Off the convex path</title>
    <description>Algorithms off the convex path.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
     
      <item>
        <title>The search for biologically plausible neural computation&amp;#58; Non-negative similarity-based networks for clustering and manifold tiling</title>
        <description>&lt;p&gt;In the &lt;a href=&quot;http://www.offconvex.org/2018/12/03/MityaNN2/&quot;&gt;previous post&lt;/a&gt; of this series, we introduced novel biologically-plausible neural networks (NNs) the operation of which, including both neural activity dynamics and local synaptic learning rules, is derived by optimizing a similarity-based objective. When the output of such NNs is constrained to be non-negative as suggested by biology, they empirically solve interesting tasks such as clustering and manifold learning. But finding the optimal solution for a constrained similarity-based objective is often challenging similarly to that for the non-negative matrix factorization problem.&lt;/p&gt;

&lt;p&gt;Here, we introduce a simplified similarity-based objective that allows us to make progress with the analysis and admits an intuitive interpretation. First, we address the simpler clustering task which, for highly segregated data, has a straightforward optimal solution. Second, we address manifold learning by viewing it as a soft-clustering problem. Finally, we discuss evidence from the brain and remaining open questions.&lt;/p&gt;

&lt;h2 id=&quot;a-similarity-based-cost-function-and-nn-for-clustering&quot;&gt;A similarity-based cost function and NN for clustering&lt;/h2&gt;

&lt;p&gt;The key to our analysis is formulating a similarity-based cost function optimization of which will yield an online algorithm and a NN for clustering. Let ${\bf x}_{t=1,…,T}\in \mathbb{R}^n$ be a set of data points (inputs). We define the similarity of a pair of inputs, ${\bf x}_t$ and ${\bf x} _{t’}$, as their dot-product, ${\bf x}_t^\top {\bf x} _{t’}$. We would like to assign inputs to $k$ clusters based on pairwise similarities, so that the algorithm outputs cluster assignment indices ${\bf y} _{t=1,…,T} \in \mathbb{R}^k$.&lt;/p&gt;

&lt;p&gt;To arrive at a cost function, consider first a single pair of data points, ${\bf x}_1$ and ${\bf x}_2$. If their similarity, ${\bf x} _1^\top {\bf x} _{2} &amp;lt; \alpha$, where $\alpha$ is a pre-set threshold, then the points should be assigned to separate clusters, i.e. ${\bf y} _1 = [1,0]^\top$ and  ${\bf y} _2 = [0,1]^\top$, setting output similarity, ${\bf y} _1^\top{\bf y} _{2}$ to 0. If ${\bf x} _1^\top {\bf x} _{2}&amp;gt;\alpha$, then the points are assigned to the same cluster, e.g. ${\bf y} _1={\bf y} _{2} = [1,0]^\top$. Such ${\bf y} _1$ and ${\bf y} _2$ are optimal solutions (although not unique) to the following optimization problem:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{ {\bf y} _1\geq 0,{\bf y} _2\geq 0 } \left(\alpha-{\bf x} _1^\top {\bf x}_2\right) {\bf y} _1^\top {\bf y} _{2}, \qquad {\rm s.t.} \quad \left\Vert{\bf y} _1\right\Vert _2 \leq 1, \, \left\Vert{\bf y} _{2}\right\Vert _2 \leq 1, \quad (3.1)&lt;/script&gt;

&lt;p&gt;where, in abuse of notation, ${\bf y} _t\geq 0 $  means that every component of the vector ${\bf y} _t$ is nonnegative.&lt;/p&gt;

&lt;p&gt;To obtain an objective function that would cluster the whole dataset of $T$ inputs we simply sum (3.1) over all possible input pairs:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{ {\bf y} _1\geq 0,...,{\bf y} _T\geq 0 } \sum_{t=1}^T\sum_{t'=1}^T\left(\alpha-{\bf x} _t^\top {\bf x} _{t'}\right){\bf y} _t^\top{\bf y} _{t'} \qquad \qquad  \qquad\\
{\rm s.t.}\quad \left\Vert{\bf y} _1\right\Vert _2\leq 1, \quad\ldots\quad ,\left\Vert{\bf y} _T\right\Vert _2\leq 1.\qquad \qquad (3.2)&lt;/script&gt;

&lt;p&gt;Does optimization of (3.2) produce the desired clustering output? This depends on the dataset. If a threshold, $\alpha$, exists such that the similarities of all pairs within the same cluster are greater and similarities of pairs from different clusters are less than $\alpha$, then the cost function (3.2) is minimized by the desired hard-clustering output, provided that $k$ is greater than or equal to the number of clusters (Figure 1A).&lt;/p&gt;

&lt;p&gt;To solve the objective (3.2) in the online setting, we introduce the constraints in the cost via Lagrange multipliers and using the variable substitution trick from the previous blog post in the series, &lt;a href=&quot;http://papers.nips.cc/paper/7939-manifold-tiling-localized-receptive-fields-are-optimal-in-similarity-preserving-neural-networks&quot;&gt;we can derive a NN implementation of this algorithm&lt;/a&gt; (Figure 1B).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://drive.google.com/uc?export=view&amp;amp;id=1PdNPaWT8Ikdo6uJ_cUOIB6LtOaoCjXEX&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 1:  A) An artificial dataset and corresponding optimal output vectors. Points are colored and grouped with respect to assigned clusters.  B) A biologically-plausible excitatory-inhibitory NN implementation of the algorithm. &lt;a href=&quot;http://papers.nips.cc/paper/7939-manifold-tiling-localized-receptive-fields-are-optimal-in-similarity-preserving-neural-networks&quot;&gt;In this version&lt;/a&gt;, anti-Hebbian synapses operate at a faster time scale than Hebbian synapses.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;manifold-tiling-solutions&quot;&gt;Manifold-tiling solutions&lt;/h2&gt;

&lt;p&gt;In many real-world problems, data points are not well-segregated but lie on low-dimensional manifolds. For such data, &lt;a href=&quot;http://papers.nips.cc/paper/7939-manifold-tiling-localized-receptive-fields-are-optimal-in-similarity-preserving-neural-networks&quot;&gt;the optimal solution of the objective (3.2) effectively tiles the  data manifold&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We can understand such optimal solutions using soft-clustering, i.e. clustering where each stimulus may be assigned to more than one cluster and assignment indices are real numbers between zero and one. Each output neuron is characterized by the weight vector of incoming synapses which defines a centroid in the input data space. The response of a neuron is maximum when data fall on the centroid and decays away from it. Manifold-tiling solutions for several datasets are shown in Figure 2.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://drive.google.com/uc?export=view&amp;amp;id=1eWZ-63hxp1yiSVqCa4qnJ20Uspi5FVxi&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 2:  &lt;a href=&quot;http://papers.nips.cc/paper/7939-manifold-tiling-localized-receptive-fields-are-optimal-in-similarity-preserving-neural-networks&quot;&gt;Analytical and numerical manifold-tiling solutions of (3.2) for representative datasets provide accurate and useful representations.&lt;/a&gt; A) A circular manifold (left) is tiled by  overlapping localized receptive fields (right). In the continuum limit ($k\rightarrow \infty$), receptive fields are truncated cosines of the polar angle, $\theta$. B) Similar analytical and numerical results are obtained for a spherical 3D manifold. We show a few receptive fields in different colors over three different views of the spherical manifold.  C) Learning the manifold of the 0 digit from the MNIST dataset by tiling the manifold with
overlapping localized receptive fields. Left: Two-dimensional linear embedding (PCA) of the outputs. The data gets organized according to different visual characteristics
of the hand-written digit (e.g., orientation and elongation). Right: A few receptive fields in different colors over the low-dimensional embedding.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We can prove this result analytically by taking advantage of the convex formulation in the limit of infinite $k$. Indeed, if we introduce Gramians ${\bf D}$, such that $D _{tt’}={\bf x} _t^\top {\bf x} _{t’}$, and ${\bf Q}$, such that $Q _{tt’}= {\bf y} _t^\top {\bf y} _{t’}$ and do not specify the dimensionality of ${\bf y}$ by leaving the rank of ${\bf Q}$ open, we can rewrite (3.2) as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{ {\bf Q}\in \mathcal{CP}^T ,\, {\rm diag}{\bf Q} \le{\bf 1} }
 -{\rm Tr}(({\bf D}-\alpha {\bf E}){\bf Q}). \qquad (3.3)&lt;/script&gt;

&lt;p&gt;where a $T\times T$ matrix belongs to a &lt;a href=&quot;https://books.google.com/books/about/Completely_Positive_Matrices.html?id=d3JpDQAAQBAJ&quot;&gt;&lt;em&gt;completely positive&lt;/em&gt;&lt;/a&gt; cone denoted by $\mathcal{CP}^T$, i.e. ${\bf Q}\equiv{\bf Y}^\top{\bf Y}$ with ${\bf Y}\ge 0$.  Redefining the variables makes the optimization problem convex. For arbitrary datasets, &lt;a href=&quot;https://books.google.com/books/about/Completely_Positive_Matrices.html?id=d3JpDQAAQBAJ&quot;&gt;optimization problems in $\mathcal{CP}^T$ are often intractable for large $T$&lt;/a&gt;, despite the convexity. &lt;a href=&quot;http://papers.nips.cc/paper/7939-manifold-tiling-localized-receptive-fields-are-optimal-in-similarity-preserving-neural-networks&quot;&gt;However, for symmetric datasets, i.e. circle, 2-sphere and SO(3), we can optimize (3.3) by analyzing the  Karush–Kuhn–Tucker conditions&lt;/a&gt; (Figure 2).&lt;/p&gt;

&lt;h2 id=&quot;other-similarity-based-nn-approaches-to-clustering-and-manifold-tiling&quot;&gt;Other similarity-based NN approaches to clustering and manifold-tiling&lt;/h2&gt;

&lt;p&gt;While we chose to present our similarity-based NN approach through the cost function in (3.2), similar results can be obtained for other versions of similarity-based clustering objective functions. The nonnegative similarity-matching cost function Eq. (2.10) introduced in the &lt;a href=&quot;http://www.offconvex.org/2018/12/03/MityaNN2/&quot;&gt;previous post&lt;/a&gt; of this series, and the NN derived from it (Figure 3A) can be used for clustering (see &lt;a href=&quot;https://www.cc.gatech.edu/~hpark/papers/DaDingParkSDM12.pdf&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1503.00680&quot;&gt;here&lt;/a&gt;) and &lt;a href=&quot;http://papers.nips.cc/paper/7939-manifold-tiling-localized-receptive-fields-are-optimal-in-similarity-preserving-neural-networks&quot;&gt;manifold learning&lt;/a&gt; as well. &lt;a href=&quot;https://www.biorxiv.org/content/early/2018/01/27/226746&quot;&gt;The $k$-means cost function can be cast into a similarity-based form and an NN (Figure 3B) can be derived for its online implementation&lt;/a&gt;. Finally, all these NNs here can be augmented by an initial &lt;a href=&quot;https://papers.nips.cc/paper/3628-kernel-methods-for-deep-learning&quot;&gt;random, nonlinear projection layer&lt;/a&gt; to &lt;a href=&quot;https://www.researchgate.net/publication/320165071_Neural_Networks_for_Efficient_Nonlinear_Online_Clustering&quot;&gt;perform clustering in the feature space associated with certain kernels&lt;/a&gt;  (Figure 3C).&lt;/p&gt;

&lt;p&gt;Objective (3.2) is related to the previously studied convex relaxation of community detection in graphs (see &lt;a href=&quot;https://arxiv.org/abs/1406.5647&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1404.6000&quot;&gt;here&lt;/a&gt;), which is closely related to clustering. If, instead of the nonnegativity of ${\bf Y}$ we require the nonnegativity of ${\bf Q}$ we arrive at an semidefinite programming formulation:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{ {\bf Q} \succeq 0,  \, {\bf Q}\geq 0, \, {\rm diag}{\bf Q} \le{\bf 1} } -{\rm Tr} (({\bf D}-\alpha {\bf E}){\bf Q}). \qquad\quad (3.4)&lt;/script&gt;

&lt;p&gt;Finally, we introduced a soft-$k$-means cost, also a relaxation of another semidefinite program for clustering (see &lt;a href=&quot;http://www.cs.utexas.edu/users/ai-lab/pubs/kernel-kdd-05.pdf&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1408.4045&quot;&gt;here&lt;/a&gt;), and an &lt;a href=&quot;https://www.biorxiv.org/content/early/2018/01/27/226746&quot;&gt;associated NN&lt;/a&gt; (Figure 3B), and &lt;a href=&quot;http://jmlr.org/papers/volume19/18-088/18-088.pdf&quot;&gt;showed that they can perform manifold tiling&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://drive.google.com/uc?export=view&amp;amp;id=1vZdXpUY8eOcCRaLd_bBdol0tEUH-XV4H&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 3:  Other biologically-plausible NNs for clustering and manifold learning. A) Nonnegative similarity matching network, also introduced in the previous blog post. B) Hard and soft $k$-means networks. Rectified neurons are perfect (hard $k$-means) or leaky (soft $k$-means) integrators. They have learned (homeostatic) activation thresholds and ephaptic couplings. C) When augmented with a hidden nonlinear layer, the presented networks perform clustering in the nonlinear feature space. Shown is the NN given &lt;a href=&quot;https://www.researchgate.net/publication/320165071_Neural_Networks_for_Efficient_Nonlinear_Online_Clustering&quot;&gt;here&lt;/a&gt;, where the hidden layer is formed of &lt;a href=&quot;https://papers.nips.cc/paper/3182-random-features-for-large-scale-kernel-machines&quot;&gt;Random Fourier Features&lt;/a&gt; to obtain a low-rank approximation to a Gaussian kernel. Hence, the whole two-layer NN operates as an online kernel clustering algorithm.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;manifold-tiling-and-clustering-in-the-brain&quot;&gt;Manifold-tiling and clustering in the brain&lt;/h2&gt;

&lt;p&gt;Similarity-based networks were originally introduced to model brain function. Indeed, clustering and manifold learning are encountered in the brain. Although sensory stimuli are nominally very high-dimensional (up to $\sim 10^{5-6}$) natural stimuli often populate low-dimensional manifolds. Learning such manifolds is essential for avoiding the curse of dimensionality. In many brain areas, neurons collectively tile the stimulus manifold, each responding only to a small neighborhood of the stimulus space.  For example, a hippocampus place cell is &lt;a href=&quot;http://www.cognitivemap.net/HCMpdf/HCMComplete.pdf&quot;&gt;active in a particular spatial location&lt;/a&gt;  (Figure 4), the response of a V1 neuron is &lt;a href=&quot;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1359523/pdf/jphysiol01247-0121.pdf&quot;&gt;localized in visual space and orientation&lt;/a&gt;, and the response of an auditory neuron is &lt;a href=&quot;http://science.sciencemag.org/content/202/4369/778.long&quot;&gt;localized in the sound frequency space&lt;/a&gt;. Further, all these responses are learned in an activity-dependent manner and can be shaped by varying stimulus statistics and perturbing neural activity.&lt;/p&gt;

&lt;p&gt;Olfactory object recognition in insects &lt;a href=&quot;https://www.biorxiv.org/content/early/2018/01/27/226746&quot;&gt;can be modeled by a clustering network&lt;/a&gt;, (Figure 3B).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/5/5e/Place_Cell_Spiking_Activity_Example.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 4:  Illustration of place cells from &lt;a href=&quot;https://en.wikipedia.org/wiki/Place_cell&quot;&gt;Wikipedia&lt;/a&gt;: ``Spatial firing patterns of 8 place cells recorded from the CA1 layer of a rat. The rat ran back and forth along an elevated track, stopping at each end to eat a small food reward. Dots indicate positions where action potentials were recorded, with color indicating which neuron emitted that action potential.”&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;remaining-challenges&quot;&gt;Remaining challenges&lt;/h2&gt;

&lt;p&gt;As discussed in this and previous posts of the series, similarity-based NNs can solve unsupervised tasks such as dimensionality reduction, clustering and manifold learning in a biologically plausible way. Yet, despite these successes of similarity-based NNs, many interesting challenges remain. Next, we list a few of them.&lt;/p&gt;

&lt;p&gt;Whereas numerical experiments indicate that our online algorithms perform well, most of them lack  global convergence proofs. Even for PCA networks we can only prove linear stability of the desired solution in the stochastic approximation setting.&lt;/p&gt;

&lt;p&gt;Motivated by biological learning which is mostly unsupervised we focused on unsupervised learning. Yet, supervision or reinforcement takes place in the brain. Therefore, it is desirable to extend our framework to supervised, semi-supervised and reinforcement learning settings. Naturally, such extensions may be valuable also as general purpose machine learning algorithms.&lt;/p&gt;

&lt;p&gt;Whereas most sensory stimuli are correlated time series, we assumed that data points at different times are independent. How are temporal correlations analyzed by NNs? Solving this problem is important both for modeling brain function and developing general purpose machine learning algorithms.&lt;/p&gt;

&lt;p&gt;Another challenge is stacking similarity-based NNs. &lt;a href=&quot;https://arxiv.org/abs/1702.06456&quot;&gt;Heuristic approach to stacking yields promising results&lt;/a&gt;. Yet, except for the Nonnegative ICA problem introduced in the &lt;a href=&quot;http://www.offconvex.org/2018/12/03/MityaNN2/&quot;&gt;previous post&lt;/a&gt;, we do not have a theoretical understanding of how and why to stack similarity-based NNs.&lt;/p&gt;

&lt;p&gt;Finally, neurons in biological NNs signal each other using all-or-none spikes, or action potentials, as opposed to real-valued signals we considered. Is there a  normative theory accounting for spiking in biological NNs?&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Jan 2019 02:45:00 -0800</pubDate>
        <link>http://localhost:4000/2019/01/06/MityaNN3/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/06/MityaNN3/</guid>
      </item>
     
    
     
      <item>
        <title>The search for biologically plausible neural computation&amp;#58; A similarity-based approach</title>
        <description>&lt;p&gt;This is the second post in a series reviewing recent progress in designing artificial neural networks (NNs) that resemble natural NNs not just superficially, but on a deeper, algorithmic level. In addition to serving as models of natural NNs, such networks can serve as general-purpose machine learning algorithms. Respecting biological constraints, viewed  naively as a handicap in developing competitive general-purpose machine learning algorithms, can instead facilitate the development of artificial NNs by restricting the search space of possible algorithms.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;http://www.offconvex.org/2016/11/03/MityaNN1/&quot;&gt;the previous post&lt;/a&gt;, we focused on the constraints that must be met for an unsupervised algorithm to be biologically plausible. For an algorithm to be implementable as a NN, it must be formulated in the online setting. In the corresponding NN, synaptic weight updates must be local, i.e. depend on the activity of only two neurons that the synapse connects. Then, we demonstrated that deriving NNs for dimensionality reduction in a conventional way - by minimizing the reconstruction error - results in multi-neuron networks with biologically implausible non-local learning rules.&lt;/p&gt;

&lt;p&gt;In this post, we propose a different objective function which we term similarity matching. From this objective function, we derive an online algorithm implementable by a NN with local learning rules. Then, we introduce other similarity-based algorithms which include more biological features such as different neuron classes and nonlinear activation functions. Finally, we review similarity-matching algorithms with state-of-the-art performance.&lt;/p&gt;

&lt;h2 id=&quot;similarity-matching-objective-function&quot;&gt;Similarity-matching objective function&lt;/h2&gt;

&lt;p&gt;We start by stating an objective function that will be used to derive NNs for linear dimensionality reduction. Let ${\bf x}_t\in \mathbb{R}^n$, $t = 1,\ldots T$, be a set of data points (inputs) and ${\bf y}_t\in \mathbb{R}^k$, $t = 1,\ldots T$, ($k &amp;lt; n$) be their learned representation (outputs). The similarity of a pair of inputs, ${\bf x}$&lt;sub&gt;&lt;small&gt;$t$&lt;/small&gt;&lt;/sub&gt; and ${\bf x}$&lt;sub&gt;&lt;small&gt;$t’$&lt;/small&gt;&lt;/sub&gt;, can be defined as their dot-product, ${\bf x}$&lt;sub&gt;&lt;small&gt;$t$&lt;/small&gt;&lt;/sub&gt;${}^\top {\bf x}$&lt;sub&gt;&lt;small&gt;$t’$&lt;/small&gt;&lt;/sub&gt;. Analogously, the similarity of a pair of outputs is ${\bf y}$&lt;sub&gt;&lt;small&gt;$t$&lt;/small&gt;&lt;/sub&gt;${}^\top {\bf y}$&lt;sub&gt;&lt;small&gt;$t’$&lt;/small&gt;&lt;/sub&gt;. Similarity matching, as its name suggests, learns a representation where the similarity between each pair of outputs matches that of the corresponding inputs:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{ {\bf y}_1,\ldots,{\bf y}_T}  \frac{1}{T^2}  \sum_{t=1}^T  \sum_{t'=1}^T \left({\bf x}_t^\top {\bf x}_{t'} - {\bf y}_t^\top {\bf y}_{t'} \right)^2. \qquad\qquad (2.1)&lt;/script&gt;

&lt;p&gt;This offline objective function, &lt;a href=&quot;https://en.wikipedia.org/wiki/Multidimensional_scaling&quot;&gt;previously employed for multidimensional scaling&lt;/a&gt;, is optimized by the projections of inputs onto the principal subspace of their covariance, i.e. performing PCA up to an orthogonal rotation. Moreover, &lt;a href=&quot;http://papers.nips.cc/paper/6048-matrix-completion-has-no-spurious-local-minimum&quot;&gt;(2.1) has no local minima other than the principal subspace solution&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The similarity-matching objective (2.1) may seem like a strange choice for deriving an online algorithm implementable by a NN.  In the online setting, inputs are streamed to the algorithm sequentially and each output must be computed before the next input arrives. Yet, in (2.1), pairs of inputs and outputs from different time points interact with each other. In addition, whereas ${\bf x}_t$ and ${\bf y}_t$ could be interpreted as inputs and outputs to a network, unlike in &lt;a href=&quot;http://www.offconvex.org/2016/11/03/MityaNN1/&quot;&gt;the reconstruction approach (1.4)&lt;/a&gt;, synaptic weights do not appear explicitly in (2.1).&lt;/p&gt;

&lt;h2 id=&quot;variable-substitution-trick&quot;&gt;Variable substitution trick&lt;/h2&gt;

&lt;p&gt;Both of the above concerns can be resolved by a &lt;a href=&quot;https://www.researchgate.net/publication/315570715_Why_Do_Similarity_Matching_Objectives_Lead_to_HebbianAnti-Hebbian_Networks&quot;&gt;simple math trick akin to completing the square&lt;/a&gt;. We first focus on the cross-term in (2.1), which we call similarity alignment. By re-ordering the variables and introducing a new variable, ${\bf W} \in  \mathbb{R}^{k\times n}$, we obtain:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;- \frac{1}{T^2}\sum_{t=1}^T \sum_{t'=1}^T  {\bf y}_{t}^\top {\bf y}_{t'} {\bf x}_t^\top {\bf x}_{t'}= - \frac{1}{T^2}\sum_{t=1}^T  {\bf y}_{t}^\top  \left[ \sum_{t'=1}^T {\bf y}_{t'} {\bf x}_{t'}^\top \right ] {\bf x}_t&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\qquad \qquad \qquad \qquad\qquad \qquad \qquad \quad =   \min_{ {\bf W} \in \mathbb{R}^{k\times n}}  -\frac{2}{T} \sum_{t=1}^T{\bf y}_t^\top {\bf W} {\bf x}_t + {\rm Tr } {\bf W}^\top {\bf W}.\; (2.2)&lt;/script&gt;

&lt;p&gt;To prove the second identity, find optimal ${\bf W}$ by taking a derivative of the expression on the right with respect to ${\bf W}$ and setting it to zero, and then substitute the optimal ${\bf W}$ back into the expression. Similarly, for the quartic ${\bf y}_t$ term in (2.1):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{1}{T^2}\sum_{t=1}^T \sum_{t'=1}^T  {\bf y}_{t}^\top {\bf y}_{t'} {\bf y}_t^\top {\bf y}_{t'}= \frac{1}{T^2}\sum_{t=1}^T  {\bf y}_{t}^\top  \left[ \sum_{t'=1}^T {\bf y}_{t'} {\bf y}_{t'}^\top \right ] {\bf y}_t&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\qquad \qquad \qquad \qquad\qquad \qquad \qquad \quad =   \max_{ {\bf M} \in \mathbb{R}^{k\times k}}  \frac{2}{T} \sum_{t=1}^T{\bf y}_t^\top {\bf M} {\bf y}_t - {\rm Tr }  {\bf M}^\top {\bf M}.\quad(2.3)&lt;/script&gt;

&lt;p&gt;By substituting (2.2) and (2.3) into (2.1) we get:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{ {\bf W}\in \mathbb{R}^{k\times n}}\max_{ {\bf M}\in \mathbb{R}^{k\times k}}  \frac{1}{T} \sum_{t=1}^T \left[2 {\rm Tr}\left({\bf W}^\top{\bf W}\right) - {\rm Tr}\left({\bf M}^\top{\bf M}\right) +  \min_{ {\bf y}_t\in \mathbb{R}^{k\times 1}}  l_t({\bf W},{\bf M},{\bf y}_t)\right],\; (2.4)&lt;/script&gt;

&lt;p&gt;where&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;l_t({\bf W},{\bf M},{\bf y}_t)=-4{\bf x}_t^\top{\bf W}{\bf y}_t + 2{\bf y}_t^\top{\bf M}{\bf y}_t.\qquad\qquad (2.5)&lt;/script&gt;

&lt;p&gt;In the resulting objective function, (2.4),(2.5), optimal outputs at different time steps can be computed independently, making the problem amenable to an online algorithm. The price paid for this simplification is the appearance of the minimax optimization problem in variables, ${\bf W}$ and ${\bf M}$. Minimization over ${\bf W}$ aligns output channels with the greatest variance directions of the input and maximization over ${\bf M}$ diversifies the output channels. The competition between the two in a gradient descent/ascent algorithm results in the principal subspace projection which is &lt;a href=&quot;https://www.researchgate.net/publication/315570715_Why_Do_Similarity_Matching_Objectives_Lead_to_HebbianAnti-Hebbian_Networks&quot;&gt;the only stable fixed point of the corresponding dynamics&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;online-algorithm-and-neural-network&quot;&gt;Online algorithm and neural network&lt;/h2&gt;

&lt;p&gt;Now, we are ready to derive an algorithm for optimizing  (2.1) online. First, by  minimizing (2.5) with respect to ${\bf y}_t$ while keeping ${\bf W}$ and ${\bf M}$ fixed we get the dynamics for the output variables :&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dot{\bf y}_t={\bf W} {\bf x}_t-{\bf M} {\bf y}_t.\qquad\qquad (2.6)&lt;/script&gt;

&lt;p&gt;To find ${\bf y}_t$ after the presentation of the corresponding input, ${\bf x}_t$, (2.6) is iterated until convergence.&lt;/p&gt;

&lt;p&gt;After the convergence of ${\bf y}_t$ we update ${\bf W}$ and ${\bf M}$ by gradient descent of (2.2) and gradient ascent of (2.3) respectively:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;W_{ij} \leftarrow W_{ij} + \eta \left(y_ix_j-W_{ij}\right), \qquad   M_{ij} \leftarrow M_{ij} + \eta \left(y_iy_j-M_{ij}\right). \qquad (2.7)&lt;/script&gt;

&lt;p&gt;Algorithm (2.6),(2.7), first derived &lt;a href=&quot;https://www.researchgate.net/publication/273003026_A_HebbianAnti-Hebbian_Neural_Network_for_Linear_Subspace_Learning_A_Derivation_from_Multidimensional_Scaling_of_Streaming_Data&quot;&gt;here&lt;/a&gt;, can be naturally implemented by a biologically plausible NN, Figure 1. Here, activity (firing rate) of the upstream neurons corresponds to input variables. Output variables are computed by the dynamics of activity (2.6) in a single layer of neurons. Variables ${\bf W}$ and ${\bf M}$ are represented by the weights of synapses in feedforward and lateral connections respectively. The learning rules (2.7) are local, i.e. the weight update, $\Delta W_{ij}$, for the synapse between $j^{\rm th}$ input neuron and $i^{\rm th}$ output neuron depends only on the activities, $x_j$, of $j^{\rm th}$ input neuron and, $y_i$, of $i^{\rm th}$ output neuron, and the synaptic weight. In neuroscience, learning rules (2.7) for ${\bf W}$ and ${\bf M}$ are called Hebbian and anti-Hebbian respectively.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://drive.google.com/uc?export=view&amp;amp;id=18_7ApBztw00VwUn-Y81kOC4s8XTuXVVN&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 1: A Hebbian/Anti-Hebbian network derived from similarity matching.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To summarize, starting with the similarity-matching objective, we derived a Hebbian/anti-Hebbian NN for dimensionality reduction. The minimax objective  can be viewed as a zero-sum game played by the weights of feedforward and lateral connections. This demonstrates that synapses with local updates can still collectively work together to optimize a global objective. A similar, although not identical, NN was proposed by Foldiak heuristically. The advantage of our normative approach is that the offline solution is known. Although no proof of convergence exists in the online setting, algorithm (2.6),(2.7) performs well in practice.&lt;/p&gt;

&lt;h2 id=&quot;other-similarity-based-objectives-and-linear-networks&quot;&gt;Other similarity-based objectives and linear networks&lt;/h2&gt;

&lt;p&gt;We used the same framework to derive NNs for other computational tasks and incorporating more biological features. As the algorithm (2.6),(2.7) and the NN in Figure 1 were derived from the similarity-matching objective (2.1), they project data onto the principal subspace but do not necessarily recover principal components &lt;em&gt;per se&lt;/em&gt;. To derive PCA algorithms we modified the objective function (2.1), &lt;a href=&quot;https://arxiv.org/abs/1511.09468&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1810.06966&quot;&gt;here&lt;/a&gt;, to encourage orthogonality of ${\bf W}$. Such algorithms are implemented by NNs of the same architecture as in Figure 1 but with slightly different learning rules.&lt;/p&gt;

&lt;p&gt;Although the similarity-matching NN in Figure 1 relies on biologically plausible local learning rules, it lacks biological realism in several other ways. For example, computing output requires recurrent activity that must settle faster than the time scale of the input variation, which is unlikely in biology. To respect this biological constraint, &lt;a href=&quot;https://arxiv.org/abs/1810.06966&quot;&gt;we modified&lt;/a&gt; the dimensionality reduction algorithm to avoid recurrency.&lt;/p&gt;

&lt;p&gt;Another non-biological feature of the NN in Figure 1 is that the output neurons compete with each other by communicating via lateral connections. In biology, such interactions are not direct but mediated by interneurons. To reflect these observations, we modified the objective function by introducing a whitening constraint:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{ {\bf y}_1,\ldots,{\bf y}_T}  - \frac{1}{T^2}\sum_{t=1}^T \sum_{t'=1}^T  {\bf y}_{t}^\top {\bf y}_{t'} {\bf x}_t^\top {\bf x}_{t'}, \qquad {\rm s.t.} \quad \frac 1T \sum_{t=1}^T {\bf y}_t {\bf y}_t^\top = {\bf I}_k, \qquad (2.8)&lt;/script&gt;

&lt;p&gt;where ${\bf I}$&lt;sub&gt;&lt;small&gt;$k$&lt;/small&gt;&lt;/sub&gt; is the $k$-by-$k$ identity matrix. Then, by representing the whitening constraint using Lagrange relaxation, &lt;a href=&quot;http://papers.nips.cc/paper/5885-a-normative-theory-of-adaptive-dimensionality-reduction-in-neural-networks&quot;&gt;we derived NNs&lt;/a&gt; where interneurons appear naturally - their activity is modeled by the Lagrange multipliers, ${\bf z} _t^\top {\bf z} _{t’}$ (Figure 2):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{ {\bf y}_1,\ldots,{\bf y}_T} \max_{ {\bf z}_1,\ldots,{\bf z}_T } - \frac{1}{T^2}\sum_{t=1}^T \sum_{t'=1}^T  {\bf y}_{t}^\top {\bf y}_{t'} {\bf x}_t^\top {\bf x}_{t'} + \frac{1}{T^2}\sum_{t=1}^T \sum_{t'=1}^T  {\bf z}_{t}^\top {\bf z}_{t'} \left({\bf y}_{t}^\top {\bf y}_{t'} -\delta_{t,t'}\right). \; (2.9)&lt;/script&gt;

&lt;p&gt;Notice how (2.9) contains the ${\bf y}$-${\bf z}$ similarity-alignment term similar to (2.2). We can now derive learning rules for the ${\bf y}$-${\bf z}$ connections using the variable substitution trick, leading to the network in Figure 2. For details of this and other NN derivations, see &lt;a href=&quot;http://papers.nips.cc/paper/5885-a-normative-theory-of-adaptive-dimensionality-reduction-in-neural-networks&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://drive.google.com/uc?export=view&amp;amp;id=1tYmjxDN2SUZY-8--uV_qGTb_gEIg0O8C&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 2: A biologically-plausible NN for whitening inputs, derived from a constrained similarity-alignment cost function.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;nonnegative-similarity-matching-objective-and-a-nonlinear-network&quot;&gt;Nonnegative similarity-matching objective and a nonlinear network&lt;/h2&gt;

&lt;p&gt;So far, we considered similarity-based NNs with linear neurons. However, biological neurons are not linear and many interesting computations require nonlinearity. A resolution to this discrepancy was suggested by the observation that the output of biological neurons is nonnegative (firing rate cannot be below zero). Hence, we modified the optimization problem by requiring that the output of the similarity-matching cost function (2.1) is nonnegative:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{ {\bf y}_1,\ldots,{\bf y}_T \geq 0}  \frac{1}{T^2}  \sum_{t=1}^T  \sum_{t'=1}^T \left({\bf x}_t^\top {\bf x}_{t'} - {\bf y}_t^\top {\bf y}_{t'} \right)^2. \qquad\qquad (2.10)&lt;/script&gt;

&lt;p&gt;Solutions of the optimization problem (2.10) are very different from PCA: They can &lt;a href=&quot;https://arxiv.org/abs/1503.00680&quot;&gt;cluster well-segregated data and extract sparse features from data&lt;/a&gt; . Understanding the nature of these solutions will be the topic of the next post. For now, we note that (2.10) can be solved by the same online algorithm as  (2.1) except that the output variables are projected onto the nonnegative domain. Such algorithm maps onto the same network as Figure 1 but with rectifying neurons (ReLUs), Figure 3A.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://drive.google.com/uc?export=view&amp;amp;id=1QahRt7mzirInGnmuSJh-4R4b88q9gyRq&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 3: A) A nonlinear Hebbian/Anti-Hebbian network derived from nonnegative similarity matching. B) Stacked network for NICA. NSM - nonnegative similarity-matching.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Another problem solved by similarity-based networks is &lt;a href=&quot;https://www.researchgate.net/publication/317300210_Blind_Nonnegative_Source_Separation_Using_Biological_Neural_Networks&quot;&gt;the nonnegative independent component analysis&lt;/a&gt; (NICA) which can be used for blind source separation. The problem is to recover independent and nonnegative sources from  observing only their linear mixture. &lt;a href=&quot;https://www.researchgate.net/publication/3342750_Conditions_for_nonnegative_independent_component_analysis&quot;&gt;Plumbley showed&lt;/a&gt; that NICA can be solved in two steps, Figure 4. First, whiten the data to obtain an orthogonal rotation of the sources. Second, find an orthogonal rotation of the whitened sources that yields a nonnegative output, Figure 4.  The first step can be implemented by the whitening network in Figure 2. The second step can be implemented by the nonnegative similarity-matching network, Figure 3A, because an orthogonal rotation does not affect dot-product similarities. Therefore, &lt;a href=&quot;https://www.researchgate.net/publication/317300210_Blind_Nonnegative_Source_Separation_Using_Biological_Neural_Networks&quot;&gt;NICA is solved by stacking the whitening and the nonnegative similarity-matching networks&lt;/a&gt;, Figure 3B.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://drive.google.com/uc?export=view&amp;amp;id=16uJTV1QQpwcZcueXLCqNJieKzyWk0ZYd&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 4: Illustration of the nonnegative independent component analysis algorithm. Two source channels (left) are linearly transformed to a two-dimensional mixture, which are the inputs to the algorithm (middle). Whitening (right) yields an orthogonal rotation of the sources. Sources are then recovered by solving the nonnegative similarity-matching problem. Green and red plus signs track two source vectors across mixing and whitening stages.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;similarity-based-algorithms-as-general-purpose-tools&quot;&gt;Similarity-based algorithms as general-purpose tools&lt;/h2&gt;

&lt;p&gt;While the derivation of the similarity-matching algorithm was motivated by constraints imposed by biology, the resulting algorithm performs well on large-scale data. &lt;a href=&quot;https://arxiv.org/abs/1808.02083&quot;&gt;A recent paper&lt;/a&gt; introduced an efficient modification of the similarity-matching algorithm and demonstrated its competitiveness with the state-of-the-art principal subspace projection algorithms in both processing speed and convergence rate. A package with implementations of these algorithms is &lt;a href=&quot;https://github.com/flatironinstitute/online_psp&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://github.com/flatironinstitute/online_psp_matlab&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this blog post, we introduced linear and non-linear similarity-matching NNs that can serve as models of biological NNs and as general-purpose machine-learning tools. In the next post, we will discuss the nature of the solutions to nonnegative similarity-based networks.&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Dec 2018 15:30:00 -0800</pubDate>
        <link>http://localhost:4000/2018/12/03/MityaNN2/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/03/MityaNN2/</guid>
      </item>
     
    
     
      <item>
        <title>Understanding optimization in deep learning by analyzing trajectories of gradient descent</title>
        <description>&lt;p&gt;Neural network optimization is fundamentally non-convex, and yet simple gradient-based algorithms seem to consistently solve such problems.
This phenomenon is one of the central pillars of deep learning, and forms a mystery many of us theorists are trying to unravel. 
In this post I’ll survey some recent attempts to tackle this problem, finishing off with a discussion on my &lt;a href=&quot;https://arxiv.org/pdf/1810.02281.pdf&quot;&gt;new paper with Sanjeev Arora, Noah Golowich and Wei Hu&lt;/a&gt;, which for the case of gradient descent over deep linear neural networks, provides a guarantee for convergence to global minimum at a linear rate.&lt;/p&gt;

&lt;h2 id=&quot;landscape-approach-and-its-limitations&quot;&gt;Landscape Approach and Its Limitations&lt;/h2&gt;

&lt;p&gt;Many papers on optimization in deep learning implicitly assume that a rigorous understanding will follow from establishing geometric properties of the loss &lt;em&gt;landscape&lt;/em&gt;, and in particular, of &lt;em&gt;critical points&lt;/em&gt; (points where the gradient vanishes).
For example, through an analogy with the spherical spin-glass model from condensed matter physics, &lt;a href=&quot;http://proceedings.mlr.press/v38/choromanska15.pdf&quot;&gt;Choromanska et al. 2015&lt;/a&gt; argued for what has become a colloquial conjecture in deep learning:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Landscape Conjecture:&lt;/strong&gt;
In neural network optimization problems, suboptimal critical points are very likely to have negative eigenvalues to their Hessian. 
In other words, there are almost &lt;em&gt;no poor local minima&lt;/em&gt;, and nearly all &lt;em&gt;saddle points are strict&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Strong forms of this conjecture were proven for loss landscapes of various simple problems involving &lt;strong&gt;shallow&lt;/strong&gt; (two layer) models, e.g. &lt;a href=&quot;https://papers.nips.cc/paper/6271-global-optimality-of-local-search-for-low-rank-matrix-recovery.pdf&quot;&gt;matrix sensing&lt;/a&gt;, &lt;a href=&quot;https://papers.nips.cc/paper/6048-matrix-completion-has-no-spurious-local-minimum.pdf&quot;&gt;matrix completion&lt;/a&gt;, &lt;a href=&quot;http://proceedings.mlr.press/v40/Ge15.pdf&quot;&gt;orthogonal tensor decomposition&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/pdf/1602.06664.pdf&quot;&gt;phase retrieval&lt;/a&gt;, and &lt;a href=&quot;http://proceedings.mlr.press/v80/du18a/du18a.pdf&quot;&gt;neural networks with quadratic activation&lt;/a&gt;.
There was also work on establishing convergence of gradient descent to global minimum when the Landscape Conjecture holds, as described in the excellent posts on this blog by &lt;a href=&quot;http://www.offconvex.org/2016/03/22/saddlepoints/&quot;&gt;Rong Ge&lt;/a&gt;, &lt;a href=&quot;http://www.offconvex.org/2016/03/24/saddles-again/&quot;&gt;Ben Recht&lt;/a&gt; and &lt;a href=&quot;http://www.offconvex.org/2017/07/19/saddle-efficiency/&quot;&gt;Chi Jin and Michael Jordan&lt;/a&gt;. 
They describe how gradient descent can arrive at a second order local minimum (critical point whose Hessian is positive semidefinite) by escaping all strict saddle points, and how this process is efficient given that perturbations are added to the algorithm. 
Note that under the Landscape Conjecture, i.e. when there are no poor local minima and non-strict saddles, second order local minima are also global minima.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/optimization-beyond-landscape-points.png&quot; width=&quot;100%&quot; alt=&quot;Local minima and saddle points&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;However, it has become clear that the landscape approach (and the Landscape Conjecture) cannot be applied as is to &lt;strong&gt;deep&lt;/strong&gt; (three or more layer) networks, for several reasons.
First, deep networks typically induce non-strict saddles (e.g. at the point where all weights are zero, see &lt;a href=&quot;https://papers.nips.cc/paper/6112-deep-learning-without-poor-local-minima.pdf&quot;&gt;Kawaguchi 2016&lt;/a&gt;).
Second, a landscape perspective largely ignores algorithmic aspects that empirically are known to greatly affect convergence with deep networks — for example the &lt;a href=&quot;http://proceedings.mlr.press/v28/sutskever13.html&quot;&gt;type of initialization&lt;/a&gt;, or &lt;a href=&quot;http://proceedings.mlr.press/v37/ioffe15.pdf&quot;&gt;batch normalization&lt;/a&gt;.
Finally, as I argued in my &lt;a href=&quot;http://www.offconvex.org/2018/03/02/acceleration-overparameterization/&quot;&gt;previous blog post&lt;/a&gt;, based upon &lt;a href=&quot;http://proceedings.mlr.press/v80/arora18a/arora18a.pdf&quot;&gt;work with Sanjeev Arora and Elad Hazan&lt;/a&gt;, adding (redundant) linear layers to a classic linear model can sometimes accelerate gradient-based optimization, without any gain in expressiveness, and despite introducing non-convexity to a formerly convex problem. 
Any landscape analysis that relies on properties of critical points alone will have difficulty explaining this phenomenon, as through such lens, nothing is easier to optimize than a convex objective with a single critical point which is the global minimum.&lt;/p&gt;

&lt;h2 id=&quot;a-way-out&quot;&gt;A Way Out?&lt;/h2&gt;

&lt;p&gt;The limitations of the landscape approach for analyzing optimization in deep learning suggest that it may be abstracting away too many important details.
Perhaps a more relevant question than “is the landscape graceful?” is “what is the behavior of specific optimizer &lt;strong&gt;trajectories&lt;/strong&gt; emanating from specific initializations?”.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/optimization-beyond-landscape-trajectories.png&quot; width=&quot;66%&quot; alt=&quot;Different trajectories lead to qualitatively different results&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;While the trajectory-based approach is seemingly much more burdensome than landscape analyses, it is already leading to notable progress.
Several recent papers (e.g. &lt;a href=&quot;http://proceedings.mlr.press/v70/brutzkus17a/brutzkus17a.pdf&quot;&gt;Brutzkus and Globerson 2017&lt;/a&gt;; &lt;a href=&quot;https://papers.nips.cc/paper/6662-convergence-analysis-of-two-layer-neural-networks-with-relu-activation.pdf&quot;&gt;Li and Yuan 2017&lt;/a&gt;; &lt;a href=&quot;http://proceedings.mlr.press/v70/zhong17a/zhong17a.pdf&quot;&gt;Zhong et al. 2017&lt;/a&gt;; &lt;a href=&quot;http://proceedings.mlr.press/v70/tian17a/tian17a.pdf&quot;&gt;Tian 2017&lt;/a&gt;; &lt;a href=&quot;https://openreview.net/pdf?id=rJ33wwxRb&quot;&gt;Brutzkus et al. 2018&lt;/a&gt;; &lt;a href=&quot;http://proceedings.mlr.press/v75/li18a/li18a.pdf&quot;&gt;Li et al. 2018&lt;/a&gt;; &lt;a href=&quot;https://arxiv.org/pdf/1806.00900.pdf&quot;&gt;Du et al. 2018&lt;/a&gt;; &lt;a href=&quot;http://romaincouillet.hebfree.org/docs/conf/nips_GDD.pdf&quot;&gt;Liao et al. 2018&lt;/a&gt;) have adopted this strategy, successfully analyzing different types of shallow models.
Moreover, trajectory-based analyses are beginning to set foot beyond the realm of the landscape approach — for the case of linear neural networks, they have successfully established convergence of gradient descent to global minimum under &lt;strong&gt;arbitrary depth&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;trajectory-based-analyses-for-deep-linear-neural-networks&quot;&gt;Trajectory-Based Analyses for Deep Linear Neural Networks&lt;/h2&gt;

&lt;p&gt;Linear neural networks are fully-connected neural networks with linear (no) activation.
Specifically, a depth $N$ linear network with input dimension $d_0$, output dimension $d_N$, and hidden dimensions $d_1,d_2,\ldots,d_{N-1}$, is a linear mapping from $\mathbb{R}^{d_0}$ to $\mathbb{R}^{d_N}$ parameterized by $x \mapsto W_N W_{N-1} \cdots W_1 x$, where $W_j \in \mathbb{R}^{d_j \times d_{j-1}}$ is regarded as the weight matrix of layer $j$.
Though trivial from a representational perspective, linear neural networks are, somewhat surprisingly, complex in terms of optimization — they lead to non-convex training problems with multiple minima and saddle points.
Being viewed as a theoretical surrogate for optimization in deep learning, the application of gradient-based algorithms to linear neural networks is receiving significant attention these days.&lt;/p&gt;

&lt;p&gt;To my knowledge, &lt;a href=&quot;https://arxiv.org/pdf/1312.6120.pdf&quot;&gt;Saxe et al. 2014&lt;/a&gt; were the first to carry out a trajectory-based analysis for deep (three or more layer) linear networks, treating gradient flow (gradient descent with infinitesimally small learning rate) minimizing $\ell_2$ loss over whitened data.
Though a very significant contribution, this analysis did not formally establish convergence to global minimum, nor treat the aspect of computational complexity (number of iterations required to converge).
The recent work of &lt;a href=&quot;http://proceedings.mlr.press/v80/bartlett18a.html&quot;&gt;Bartlett et al. 2018&lt;/a&gt; makes progress towards addressing these gaps, by applying a trajectory-based analysis to gradient descent for the special case of linear residual networks, i.e. linear networks with uniform width across all layers ($d_0=d_1=\cdots=d_N$) and identity initialization ($W_j=I$, $\forall j$).
Considering different data-label distributions (which boil down to what they refer to as “targets”), Bartlett et al. demonstrate cases where gradient descent provably converges to global minimum at a linear rate — loss is less than $\epsilon&amp;gt;0$ from optimum after $\mathcal{O}(\log\frac{1}{\epsilon})$ iterations — as well as situations where it fails to converge.&lt;/p&gt;

&lt;p&gt;In a &lt;a href=&quot;https://arxiv.org/pdf/1810.02281.pdf&quot;&gt;new paper with Sanjeev Arora, Noah Golowich and Wei Hu&lt;/a&gt;, we take an additional step forward in virtue of the trajectory-based approach.
Specifically, we analyze trajectories of gradient descent for any linear neural network that does not include “bottleneck layers”, i.e. whose hidden dimensions are no smaller than the minimum between the input and output dimensions ($d_j \geq \min\{d_0,d_N\}$, $\forall j$), and prove convergence to global minimum, at a linear rate, provided that initialization meets the following two conditions:
&lt;em&gt;(i)&lt;/em&gt; &lt;em&gt;approximate balancedness&lt;/em&gt; — $W_{j+1}^\top W_{j+1} \approx W_j W_j^\top$, $\forall j$;
and &lt;em&gt;(ii)&lt;/em&gt; &lt;em&gt;deficiency margin&lt;/em&gt; — initial loss is smaller than the loss of any rank deficient solution.
We show that both conditions are necessary, in the sense that violating any one of them may lead to a trajectory that fails to converge.
Approximate balancedness at initialization is trivially met in the special case of linear residual networks, and also holds for the customary setting of initialization via small random perturbations centered at zero.
The latter also leads to deficiency margin with positive probability.
For the case $d_N=1$, i.e. scalar regression, we provide a random initialization scheme under which both conditions are met, and thus convergence to global minimum at linear rate takes place, with constant probability.&lt;/p&gt;

&lt;p&gt;Key to our analysis is the observation that if weights are initialized to be approximately balanced, they will remain that way throughout the iterations of gradient descent.
In other words, trajectories taken by the optimizer adhere to a special characterization:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Trajectory Characterization:&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

  &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;W_{j+1}^\top(t) W_{j+1}(t) \approx W_j(t) W_j^\top(t), \quad j=1,\ldots,N-1, \quad t=0,1,\ldots&lt;/script&gt;,&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;which means that throughout the entire timeline, all layers have (approximately) the same set of singular values, and the left singular vectors of each layer (approximately) coincide with the right singular vectors of the layer that follows.
We show that this regularity implies steady progress for gradient descent, thereby demonstrating that even in cases where the loss landscape is complex as a whole (includes many non-strict saddle points), it may be particularly well-behaved around the specific trajectories taken by the optimizer.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Tackling the question of optimization in deep learning through the landscape approach, i.e. by analyzing the geometry of the objective independently of the algorithm used for training, is conceptually appealing.
However this strategy suffers from inherent limitations, predominantly as it requires the entire objective to be graceful, which seems to be too strict of a demand.
The alternative approach of taking into account the optimizer and its initialization, and focusing on the landscape only along the resulting trajectories, is gaining more and more traction.
While landscape analyses have thus far been limited to shallow (two layer) models only, the trajectory-based approach has recently treated arbitrarily deep models, proving convergence of gradient descent to global minimum at a linear rate.
Much work however remains to be done, as this success covered only linear neural networks.
I expect the trajectory-based approach to be key in developing our formal understanding of gradient-based optimization for deep non-linear networks as well.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cohennadav.com/&quot;&gt;Nadav Cohen&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Nov 2018 04:00:00 -0800</pubDate>
        <link>http://localhost:4000/2018/11/07/optimization-beyond-landscape/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/07/optimization-beyond-landscape/</guid>
      </item>
     
    
     
      <item>
        <title>Simple and efficient semantic embeddings for rare words, n-grams, and language features</title>
        <description>&lt;p&gt;Distributional methods for capturing meaning, such as word embeddings, often require observing many examples of words in context. But most humans can infer a reasonable meaning from very few or even a single occurrence. For instance,  if we read “Porgies live in shallow temperate marine waters,” we have a good idea that a &lt;em&gt;porgy&lt;/em&gt; is a fish. Since language corpora often have a long tail of “rare words,” it is an interesting problem to imbue NLP algorithms with this capability. This is especially important for n-grams (i.e., ordered n-tuples of words, like “ice cream”), many of which occur rarely in the corpus.&lt;/p&gt;

&lt;p&gt;Here we describe a simple but principled approach called &lt;em&gt;à la carte&lt;/em&gt; embeddings, described in our &lt;a href=&quot;http://aclweb.org/anthology/P18-1002&quot;&gt;ACL’18 paper&lt;/a&gt; with Yingyu Liang, Tengyu Ma, and Brandon Stewart. It also easily extends to learning embeddings of arbitrary language features such as word-senses and $n$-grams. The paper also combines these with our recent &lt;a href=&quot;http://www.offconvex.org/2018/06/25/textembeddings/&quot;&gt;deep-learning-free text embeddings&lt;/a&gt; to get simple deep-learning free text embeddings with even better performance on downstream classification tasks, quite competitive with deep learning approaches.&lt;/p&gt;

&lt;h2 id=&quot;inducing-word-embedding-from-their-contexts-a-surprising-linear-relationship&quot;&gt;Inducing word embedding from their contexts: a surprising linear relationship&lt;/h2&gt;

&lt;p&gt;Suppose a single occurrence of a word $w$ is surrounded by a sequence $c$ of words. What is a reasonable guess for the word embedding $v_w$  of $w$? For convenience, we will let $u_w^c$ denote the  average of the word embeddings of words in $c$. Anybody who knows the word2vec method may reasonably guess the following.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Guess 1:&lt;/strong&gt; Up to scaling, $u_w^c$ is a good estimate for $v_w$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Unfortunately, this totally fails. Even taking thousands of occurrences of $w$, the average of such estimates stays far from the ground truth embedding $v_w$. The following discovery should therefore be surprising (read below for a theoretical justification):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Theorem 1&lt;/strong&gt; (From &lt;a href=&quot;https://transacl.org/ojs/index.php/tacl/article/view/1346&quot;&gt;this TACL’18 paper&lt;/a&gt;): There is a single matrix $A$ (depending only upon the text corpus) such that $A u_w^c$ is a good estimate for $v_w$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Note that the best such $A$ can be found via linear regression by minimizing the average $|Au_w^c -v_w|^2$ over occurrences of frequent words $w$, for which we already have word embeddings.&lt;/p&gt;

&lt;p&gt;Once such an $A$ has been learnt from frequent words, the induction of embeddings for new words works very well. As we receive more and more occurrences of $w$ the average of $Au_w^c$ over all sentences containing $w$ has cosine similarity $&amp;gt;0.9$ with the true word embedding $v_w$ (this holds for GloVe as well as word2vec).&lt;/p&gt;

&lt;p&gt;Thus the learnt $A$ gives a way to induce embeddings for new words from a few or even a single occurrence. We call this the   &lt;em&gt;à la carte&lt;/em&gt; embedding of $w$,  because we don’t need to pay the &lt;em&gt;prix fixe&lt;/em&gt; of re-running GloVe or word2vec on the entire corpus each time a new word is needed.&lt;/p&gt;

&lt;h3 id=&quot;testing-embeddings-for-rare-words&quot;&gt;Testing embeddings for rare words&lt;/h3&gt;
&lt;p&gt;Using Stanford’s &lt;a href=&quot;https://nlp.stanford.edu/~lmthang/morphoNLM/&quot;&gt;Rare Words&lt;/a&gt; dataset we created the 
&lt;a href=&quot;http://nlp.cs.princeton.edu/CRW/&quot;&gt;&lt;em&gt;Contextual Rare Words&lt;/em&gt;&lt;/a&gt; dataset where, along with word pairs and human-rated scores, we also provide contexts (i.e., few usages) for the rare words.&lt;/p&gt;

&lt;p&gt;We compare the performance of our method with alternatives such as &lt;a href=&quot;http://www.offconvex.org/2018/06/17/textembeddings/&quot;&gt;top singular component removal and frequency down-weighting&lt;/a&gt; and find that &lt;em&gt;à la carte&lt;/em&gt; embedding consistently outperforms other methods and requires far fewer contexts to match their best performance.
Below we plot the increase in Spearman correlation with human ratings as the tested algorithms are given more samples of the words in context. We see that given only 8 occurences of the word, the &lt;em&gt;a la carte&lt;/em&gt; method outperforms  other baselines that’re given 128 occurences.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/ALCcrwplot.svg&quot; width=&quot;60%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Now we turn to the task mentioned in the opening para of this post. &lt;a href=&quot;http://aclweb.org/anthology/D17-1030&quot;&gt;Herbelot and Baroni&lt;/a&gt; constructed a “nonce” dataset consisting of single-word concepts and their Wikipedia definitions, to test algorithms that “simulate the process by which a competent speaker encounters a new word in known contexts.” They tested various methods, including a modified version of word2vec.
As we show in the table below, &lt;em&gt;à la carte&lt;/em&gt; embedding outperforms all their methods in terms of the average rank of the target vector’s similarity with the constructed vector. The true word embedding is among the closest 165 or so word vectors to our embedding. 
(Note that the vocabulary size exceeds 200K, so this is considered a strong performance.)&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/ALCnonce.svg&quot; width=&quot;50%&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;a-theory-of-induced-embeddings-for-general-features&quot;&gt;A theory of induced embeddings for general features&lt;/h2&gt;

&lt;p&gt;Why should the matrix $A$ mentioned above exist in the first place? 
Sanjeev, Yingyu, and Tengyu’s &lt;a href=&quot;https://transacl.org/ojs/index.php/tacl/article/view/1346&quot;&gt;TACL’18&lt;/a&gt; paper together with Yuanzhi Li and Andrej Risteski gives a justification via a latent-variable model of corpus generation that is a modification of their earlier model described in &lt;a href=&quot;https://transacl.org/ojs/index.php/tacl/article/view/742&quot;&gt;TACL’16&lt;/a&gt; (see also this &lt;a href=&quot;http://www.offconvex.org/2016/02/14/word-embeddings-2/&quot;&gt;blog post&lt;/a&gt;) The basic idea is to consider a random walk over an ellipsoid instead of the unit square. 
Under this modification of the rand-walk model, whose approximate MLE objective is similar to that of GloVe, their first theorem shows the following:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists~A\in\mathbb{R}^{d\times d}\textrm{ s.t. }v_w=A\mathbb{E} \left[\frac{1}{n}\sum\limits_{w'\in c}v_{w'}\bigg|w\in c\right]=A\mathbb{E}v_w^\textrm{avg}~\forall~w&lt;/script&gt;

&lt;p&gt;where the expectation is taken over possible contexts $c$.&lt;/p&gt;

&lt;p&gt;This result also explains the linear algebraic structure of the embeddings of polysemous words (words having multiple possible meanings, such as &lt;em&gt;tie&lt;/em&gt;) discussed in an earlier &lt;a href=&quot;http://www.offconvex.org/2016/07/10/embeddingspolysemy/&quot;&gt;post&lt;/a&gt;.
Assuming for simplicity that $tie$ only has two meanings (&lt;em&gt;clothing&lt;/em&gt; and &lt;em&gt;game&lt;/em&gt;), it is easy to see that its word embedding is a linear transformation of the sum of the average context vectors of its two senses:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;v_w=A\mathbb{E}v_w^\textrm{avg}=A\mathbb{E}\left[v_\textrm{clothing}^\textrm{avg}+v_\textrm{game}^\textrm{avg}\right]=A\mathbb{E}v_\textrm{clothing}^\textrm{avg}+A\mathbb{E}v_\textrm{game}^\textrm{avg}&lt;/script&gt;

&lt;p&gt;The above also shows that we can get a reasonable estimate for the vector of the sense &lt;em&gt;clothing&lt;/em&gt;, and, by extension many other features of interest, by setting $v_\textrm{clothing}=A\mathbb{E}v_\textrm{clothing}^\textrm{avg}$.
Note that this linear method also subsumes other context representations, such as removing the &lt;a href=&quot;http://www.offconvex.org/2018/06/17/textembeddings/&quot;&gt;top singular component or down-weighting frequent directions&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;n-gram-embeddings&quot;&gt;$n$-gram embeddings&lt;/h3&gt;

&lt;p&gt;While the theory suggests existence of a linear transform between word embeddings and their context embeddings, one could also use this linear transform to induce embeddings for other kinds of linguistic features in context.
We test this hypothesis by inducing embeddings for $n$-grams by using contexts from a large text corpus and word embeddings trained on the same corpus.
A qualitative evaluation of the $n$-gram embeddings is done by finding the closest words to it in terms of cosine similarity between the embeddings.
As evident from the below figure, &lt;em&gt;à la carte&lt;/em&gt; bigram embeddings capture the meaning of the phrase better than some other compositional and learned bigram embeddings.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/ALCngram_quality.png&quot; width=&quot;65%&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;sentence-embeddings&quot;&gt;Sentence embeddings&lt;/h3&gt;
&lt;p&gt;We also use these $n$-gram embeddings to construct sentence embeddings, similarly to &lt;a href=&quot;http://www.offconvex.org/2018/06/25/textembeddings/&quot;&gt;DisC embeddings&lt;/a&gt;, to evaluate on classification tasks.
A sentence is embedded as the concatenation of sums of embeddings for $n$-gram in the sentence for use in downstream classification tasks.
Using this simple approach we can match the performance of other linear and LSTM representations, even obtaining state-of-the-art results on some of them. Note that Logeswaran and Lee is a contemporary paper that uses deep nets.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/ALCngram_clf.svg&quot; width=&quot;80%&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;discussion&quot;&gt;Discussion&lt;/h2&gt;

&lt;p&gt;Our &lt;em&gt;à la carte&lt;/em&gt; method is simple, almost elementary, and yet gives results competitive with many other feature embedding methods and also beats them in many cases.
Can one do zero-shot learning of word embeddings, i.e. inducing embeddings for a words/features without any context?
Character level methods such as &lt;a href=&quot;https://fasttext.cc/&quot;&gt;fastText&lt;/a&gt; can do this and it is a good problem to incorporate character level information into the &lt;em&gt;à la carte&lt;/em&gt; approach (the few things we tried didn’t work so far).&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;à la carte&lt;/em&gt; code is &lt;a href=&quot;https://github.com/NLPrinceton/ALaCarte&quot;&gt;available here&lt;/a&gt;, allowing you to re-create the results described.&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Sep 2018 02:00:00 -0700</pubDate>
        <link>http://localhost:4000/2018/09/18/alacarte/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/18/alacarte/</guid>
      </item>
     
    
     
      <item>
        <title>When Recurrent Models Don't Need to be Recurrent</title>
        <description>&lt;p&gt;In the last few years, deep learning practitioners have proposed a litany of
different sequence models.  Although recurrent neural networks were once the
tool of choice, now models like the autoregressive
&lt;a href=&quot;https://deepmind.com/blog/wavenet-generative-model-raw-audio/&quot;&gt;Wavenet&lt;/a&gt; or the
&lt;a href=&quot;https://ai.googleblog.com/2017/08/transformer-novel-neural-network.html&quot;&gt;Transformer&lt;/a&gt;
are replacing RNNs on a diverse set of tasks. In this post, we explore the
trade-offs between recurrent and feed-forward models. Feed-forward models can
offer improvements in training stability and speed, while recurrent models are
strictly more expressive. Intriguingly, this added expressivity does not seem to
boost the performance of recurrent models.  Several groups have shown
feed-forward networks can match the results of the best recurrent models on
benchmark sequence tasks. This phenomenon raises an interesting question for
theoretical investigation:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When and why can feed-forward networks replace recurrent neural networks
without a loss in performance?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We discuss several proposed answers to this question and highlight our
&lt;a href=&quot;https://arxiv.org/abs/1805.10369&quot;&gt;recent work&lt;/a&gt; that offers an explanation in
terms of a fundamental stability property.&lt;/p&gt;

&lt;h1 id=&quot;a-tale-of-two-sequence-models&quot;&gt;A Tale of Two Sequence Models&lt;/h1&gt;
&lt;h2 id=&quot;recurrent-neural-networks&quot;&gt;Recurrent Neural Networks&lt;/h2&gt;
&lt;p&gt;The many variants of recurrent models all have a similar form. The model
maintains a state $h_t$ that summarizes the past sequence of inputs. At each
time step $t$, the state is updated according to the equation
[
    h_{t+1} = \phi(h_t, x_t),
]
where $x_t$ is the input at time $t$, $\phi$ is a differentiable map, and $h_0$
is an initial state. In a vanilla recurrent neural network, the model is
parameterized by matrices $W$ and $U$, and the state is updated according to
[
    h_{t+1} = \tanh(Wh_t + Ux_t).
]
In practice, the &lt;a href=&quot;http://colah.github.io/posts/2015-08-Understanding-LSTMs/&quot;&gt;Long Short-Term Memory
(LSTM)&lt;/a&gt; network is
more frequently used. In either case, to make predictions, the state is passed
to a function $f$, and the model predicts $y_t = f(h_t)$. Since the state $h_t$
is a function of all of the past inputs $x_0, \dots, x_t$, the prediction $y_t$
depends on the entire history $x_0, \dots, x_t$ as well.&lt;/p&gt;

&lt;p&gt;A recurrent model can also be represented graphically.&lt;/p&gt;
&lt;p style=&quot;text-align:center;&quot;&gt;
    &lt;img src=&quot;/assets/approx_recurrent/recurrent_net.png&quot; width=&quot;500px&quot; height=&quot;250px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Recurrent models are fit to data using backpropagation. However, backpropagating
gradients from time step $T$ to time step $0$ often requires infeasibly large
amounts of memory, so essentially every implementation of a recurrent model
&lt;em&gt;truncates&lt;/em&gt; the model and only backpropagates gradient $k$ times steps.&lt;/p&gt;
&lt;figure&gt;
    &lt;p style=&quot;text-align:center;&quot;&gt;
        &lt;img src=&quot;/assets/approx_recurrent/truncated_backprop.png&quot; /&gt;
    &lt;/p&gt;
    &lt;figcaption&gt;
    &lt;small&gt;
        Source: &lt;a href=&quot;https://r2rt.com/styles-of-truncated-backpropagation.html&quot;&gt; 
        https://r2rt.com/styles-of-truncated-backpropagation.html &lt;/a&gt;
    &lt;/small&gt;
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;In this setup, the predictions of the recurrent model still depend on the entire
history $x_0, \dots, x_T$. However, it’s not clear how this training procedure
affects the model’s ability to learn long-term patterns, particularly those that
require more than $k$ steps.&lt;/p&gt;

&lt;h2 id=&quot;autoregressive-feed-forward-models&quot;&gt;Autoregressive, Feed-Forward Models&lt;/h2&gt;
&lt;p&gt;Instead of making predictions from a state that depends on the entire history,
an autoregressive model directly predicts $y_t$ using only the $k$ most recent
inputs, $x_{t-k+1}, \dots, x_{t}$. This corresponds to a strong &lt;em&gt;conditional
independence&lt;/em&gt; assumption. In particular, a feed-forward model assumes the target
only depends on the $k$ most recent inputs. Google’s
&lt;a href=&quot;https://arxiv.org/abs/1609.03499&quot;&gt;WaveNet&lt;/a&gt; nicely illustrates this general
principle.&lt;/p&gt;

&lt;figure&gt;
    &lt;p style=&quot;text-align:center;&quot;&gt;
        &lt;img src=&quot;https://storage.googleapis.com/deepmind-live-cms/documents/BlogPost-Fig2-Anim-160908-r01.gif&quot; /&gt;
    &lt;/p&gt;
    &lt;figcaption&gt;
    &lt;small&gt;
        Source: &lt;a href=&quot;https://deepmind.com/blog/wavenet-generative-model-raw-audio/&quot;&gt; 
        https://deepmind.com/blog/wavenet-generative-model-raw-audio/&lt;/a&gt;
    &lt;/small&gt;
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;In contrast to an RNN, the limited context of a feed-forward model means that it
cannot capture patterns that extend more than $k$ steps. However, using
techniques like dilated-convolutions, one can make $k$ quite large.&lt;/p&gt;

&lt;h1 id=&quot;why-care-about-feed-forward-models&quot;&gt;Why Care About Feed-Forward Models?&lt;/h1&gt;
&lt;p&gt;At the outset, recurrent models appear to be a strictly more flexible and
expressive model class than feed-forward models. After all, feed-forward
networks make a strong conditional independence assumption that recurrent models
don’t make. Even if feed-forward models are less expressive, there are still
several reasons one might prefer a feed-forward network.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Parallelization&lt;/strong&gt;: Convolutional feed-forward models are easier to &lt;a href=&quot;https://arxiv.org/abs/1705.03122&quot;&gt;parallelize
at training time&lt;/a&gt;. 
There’s no hidden state to update and maintain, and
therefore no sequential dependencies between outputs. This allows very
efficient implementations of training on modern hardware.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Trainability&lt;/strong&gt;: Training deep convolutional neural networks is the
bread-and-butter of deep learning. Whereas recurrent models are often more
finicky and difficult to &lt;a href=&quot;https://arxiv.org/abs/1211.5063&quot;&gt;optimize&lt;/a&gt;,
significant effort has gone into designing architectures and software to
efficiently and reliably train deep feed-forward networks.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Inference Speed&lt;/strong&gt;: In some cases, feed-forward models can be significantly
more light-weight and perform &lt;a href=&quot;https://arxiv.org/abs/1211.5063&quot;&gt;inference faster than similar recurrent
systems&lt;/a&gt;. In other cases,
particularly for long sequences, autoregressive inference is a large
bottleneck and requires &lt;a href=&quot;https://arxiv.org/abs/1702.07825&quot;&gt;significant engineering
work&lt;/a&gt; or &lt;a href=&quot;https://arxiv.org/abs/1711.10433&quot;&gt;significant
cleverness&lt;/a&gt; to overcome.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;feed-forward-models-can-outperform-recurrent-models&quot;&gt;Feed-Forward Models Can Outperform Recurrent Models&lt;/h1&gt;
&lt;p&gt;Although it appears trainability and parallelization for feed-forward models
comes at the price of reduced accuracy, there have been several recent examples
showing that feed-forward networks can actually achieve the same accuracies as
their recurrent counterparts on benchmark tasks.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Language Modeling.&lt;/strong&gt;
In language modeling, the goal is to predict the next word in a document given
all of the previous words. Feed-forward models make predictions using only the
$k$ most recent words, whereas recurrent models can potentially use the entire
document.  The &lt;a href=&quot;https://arxiv.org/abs/1612.08083&quot;&gt;Gated-Convolutional Language
Model&lt;/a&gt; is a feed-forward autoregressive models
that is competitive with &lt;a href=&quot;https://arxiv.org/abs/1602.02410&quot;&gt;large LSTM baseline
models&lt;/a&gt;. Despite using a truncation length of
$k=25$, the model outperforms a large LSTM on the
&lt;a href=&quot;https://einstein.ai/research/the-wikitext-long-term-dependency-language-modeling-dataset&quot;&gt;Wikitext-103&lt;/a&gt;
benchmark, which is designed to reward models that capture long-term
dependencies. On the &lt;a href=&quot;http://www.statmt.org/lm-benchmark/&quot;&gt;Billion Word
Benchmark&lt;/a&gt;, the model is slightly worse
than the largest LSTM, but is faster to train and uses fewer resources.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Machine Translation.&lt;/strong&gt;
The goal in machine translation is to map sequences of English words to
sequences of, say, French words. Feed-forward models make translations using
only $k$ words of the sentence, whereas recurrent models can leverage the entire
sentence.  Within the deep learning world, variants of the LSTM-based &lt;a href=&quot;https://arxiv.org/abs/1409.0473&quot;&gt;Sequence
to Sequence with Attention&lt;/a&gt; model, particularly
&lt;a href=&quot;https://arxiv.org/abs/1609.08144&quot;&gt;Google Neural Machine Translation&lt;/a&gt;, were
superseded first by a fully &lt;a href=&quot;https://arxiv.org/abs/1705.03122&quot;&gt;convolutional sequence to
sequence&lt;/a&gt; model and then by the
&lt;a href=&quot;https://arxiv.org/abs/1706.03762&quot;&gt;Transformer&lt;/a&gt;.&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;p style=&quot;text-align:center;&quot;&gt;
        &lt;img src=&quot;https://raw.githubusercontent.com/facebookresearch/fairseq/master/fairseq.gif&quot; /&gt;
    &lt;/p&gt;
    &lt;figcaption&gt;
    &lt;small&gt;
        Source: &lt;a href=&quot;https://github.com/facebookresearch/fairseq/blob/master/fairseq.gif&quot;&gt; 
        https://github.com/facebookresearch/fairseq/blob/master/fairseq.gif &lt;/a&gt;
    &lt;/small&gt;
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Speech Synthesis.&lt;/strong&gt;
In speech synthesis, one seeks to generate a realistic human speech signal.
Feed-forward models are limited to the past $k$ samples, whereas recurrent
models can use the entire history. Upon publication, the feed-forward,
autoregressive &lt;a href=&quot;https://arxiv.org/abs/1609.03499&quot;&gt;WaveNet&lt;/a&gt; was a substantial
improvement over LSTM-RNN parametric models.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Everthing Else.&lt;/strong&gt; 
Recently &lt;a href=&quot;https://arxiv.org/abs/1803.01271&quot;&gt;Bai et al.&lt;/a&gt; proposed a generic
feed-forward model leveraging dilated convolutions and showed it outperforms
recurrent baselines on tasks ranging from synthetic copying tasks to music
generation.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;how-can-feed-forward-models-outperform-recurrent-ones&quot;&gt;How Can Feed-Forward Models Outperform Recurrent Ones?&lt;/h1&gt;
&lt;p&gt;In the examples above, feed-forward networks achieve results on par with or
better than recurrent networks. This is perplexing since recurrent models
seem to be more powerful a priori. One explanation for this phenomenon is
given by &lt;a href=&quot;https://arxiv.org/abs/1612.08083&quot;&gt;Dauphin et al.&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The unlimited context offered by recurrent models is not strictly necessary
for language modeling.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In other words, it’s possible you don’t need a large amount of context to do
well on the prediction task on average. &lt;a href=&quot;https://arxiv.org/abs/1612.02526&quot;&gt;Recent theoretical
work&lt;/a&gt; offers some evidence in favor of this view.&lt;/p&gt;

&lt;p&gt;Another explanation is given by &lt;a href=&quot;https://arxiv.org/abs/1803.01271&quot;&gt;Bai et al.&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The “infinite memory” advantage of RNNs is largely absent in practice.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As Bai et al. report, even in experiments explicitly requiring long-term
context, RNN variants were unable to learn long sequences. On the Billion Word
Benchmark, an &lt;a href=&quot;https://arxiv.org/abs/1703.10724&quot;&gt;intriguing Google Technical
Report&lt;/a&gt; suggests an LSTM $n$-gram model with
$n=13$ words of memory is as good as an LSTM with arbitrary context.&lt;/p&gt;

&lt;p&gt;This evidence leads us to conjecture: &lt;strong&gt;Recurrent models &lt;em&gt;trained in practice&lt;/em&gt;
are effectively feed-forward.&lt;/strong&gt; This could happen either because truncated
backpropagation time cannot learn patterns significantly longer than $k$ steps,
or, more provocatively, because models &lt;em&gt;trainable by gradient descent&lt;/em&gt; cannot
have long-term memory.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://arxiv.org/abs/1805.10369&quot;&gt;our recent paper&lt;/a&gt;, we study the gap
between recurrent and feed-forward models trained using gradient descent. We
show if the recurrent model is &lt;em&gt;stable&lt;/em&gt; (meaning the gradients can not explode),
then the model can be well-approximated by a feed-forward network for the
purposes of both &lt;em&gt;inference and training.&lt;/em&gt; In other words, we show feed-forward
and stable recurrent models trained by gradient descent are &lt;em&gt;equivalent&lt;/em&gt; in the
sense of making identical predictions at test-time. Of course, not all models
trained in practice are stable. We also give empirical evidence the stability
condition can be imposed on certain recurrent models without loss in
performance.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Despite some initial attempts, there is still much to do to understand
why feed-forward models are competitive with recurrent ones and
shed light onto the trade-offs between sequence models. How much memory is
really needed to perform well on common sequence benchmarks? What are the
expressivity trade-offs between truncated RNNs (which can be considered
feed-forward) and the convolutional models that are in popular use? Why can
feed-forward networks perform as well as unstable RNNs in practice?&lt;/p&gt;

&lt;p&gt;Answering these questions is a step towards building a theory that can both
explain the strengths and limitations of our current methods and give guidance
about how to choose between different classes of models in concrete settings.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;The Transformer isn’t strictly a feed-forward model in the style described above (since it doesn’t make the $k$ step conditional independence assumption), but is not really a recurrent model because it doesn’t maintain a hidden state. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 27 Jul 2018 01:00:00 -0700</pubDate>
        <link>http://localhost:4000/2018/07/27/approximating-recurrent/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/27/approximating-recurrent/</guid>
      </item>
     
    
     
      <item>
        <title>Deep-learning-free Text and Sentence Embedding, Part 2</title>
        <description>&lt;p&gt;This post continues &lt;a href=&quot;http://www.offconvex.org/2018/06/17/textembeddings/&quot;&gt;Sanjeev’s post&lt;/a&gt; and describes further attempts to construct elementary and interpretable text embeddings. 
The previous post described the &lt;a href=&quot;https://openreview.net/pdf?id=SyK00v5xx&quot;&gt;the SIF embedding&lt;/a&gt;, which uses a simple weighted combination of word embeddings combined with some mild “denoising” based upon singular vectors, yet outperforms many deep learning based methods, including &lt;a href=&quot;https://arxiv.org/pdf/1506.06726.pdf&quot;&gt;Skipthought&lt;/a&gt;, on certain downstream NLP tasks such as sentence semantic similarity and entailment. 
See also this &lt;a href=&quot;http://nlp.town/blog/sentence-similarity/&quot;&gt;independent study by Yves Peirsman&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However, SIF embeddings embeddings ignore word order (similar to classic &lt;em&gt;Bag of Words&lt;/em&gt; models in NLP), which leads to unexciting performance on many other downstream classification tasks. 
(Even the denoising via SVD, which is crucial in similarity tasks, can sometimes reduces performance on other tasks.) 
Can we design a text embedding with the simplicity and transparency of SIF while also incorporating word order information?
Our &lt;a href=&quot;https://openreview.net/pdf?id=B1e5ef-C-&quot;&gt;ICLR’18 paper&lt;/a&gt; with Kiran Vodrahalli does this, and achieves strong empirical performance and also some surprising theoretical guarantees stemming from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Compressed_sensing&quot;&gt;theory of compressed sensing&lt;/a&gt;. 
It is competitive with all pre-2018 LSTM-based methods on standard tasks. 
Even better, it is much faster to compute, since it uses pretrained (GloVe) word vectors and simple linear algebra.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/unsupervised_pipeline.png&quot; width=&quot;50%&quot; alt=&quot;Pipeline&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;incorporating-local-word-order-n-gram-embeddings&quot;&gt;Incorporating local word order: $n$-gram embeddings&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Bigrams&lt;/em&gt; are ordered word-pairs that appear in the sentence, and $n$-grams are ordered $n$-tuples. 
A document with $k$ words has $k-1$ bigrams and $k-n+1$ $n$-grams. 
The &lt;em&gt;Bag of n-gram (BonG) representation&lt;/em&gt; of a document refers to a long vector whose each entry is indexed by all possible $n$-grams, and contains the number of times the corresponding $n$-gram appears in the document. 
Linear classifiers trained on BonG representations are a &lt;a href=&quot;https://www.aclweb.org/anthology/P12-2018&quot;&gt;surprisingly strong baseline for document classification tasks&lt;/a&gt;.
While $n$-grams don’t directly encode long-range dependencies in text, one hopes that a fair bit of such information is implicitly present.&lt;/p&gt;

&lt;p&gt;A trivial idea for incorporating $n$-grams into SIF embeddings would be to treat $n$-grams like words, and compute word embeddings for them using either GloVe and word2vec. 
This runs into the difficulty that the number of distinct $n$-grams in the corpus gets very large even for $n=2$ (let alone $n=3$), making it almost impossible to solve word2vec or GloVe. 
Thus one gravitates towards a more &lt;em&gt;compositional&lt;/em&gt; approach.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Compositional $n$-gram embedding:&lt;/strong&gt; Represent $n$-gram $g=(w_1,\dots,w_n)$ as the element-wise product $v_g=v_{w_1}\odot\cdots\odot v_{w_n}$ of the embeddings of its constituent words.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Note that due to the element-wise multiplication we actually represent unordered $n$-gram information, not ordered $n$-grams (the performance for order-preserving methods is about the same).
Now we are ready to define our &lt;em&gt;Distributed Co-occurrence (DisC) embeddings&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;strong&gt;DisC embedding&lt;/strong&gt; of a piece of text is just a concatenation for $(v_1, v_2, \ldots)$ where $v_n$ is the sum of the $n$-gram embeddings of all $n$-grams in the document (for $n=1$ this is just the sum of word embeddings).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Note that DisC embeddings leverage classic Bag-of-n-Gram information as well as the power of word embeddings. 
For instance,  the sentences &lt;em&gt;“Loved this movie!”&lt;/em&gt; and &lt;em&gt;“I enjoyed the film.”&lt;/em&gt; share no $n$-gram information for any $n$, but  their DisC embeddings are fairly similar. 
Thus if the first example comes with a label, it gives the learner some idea of how to classify the second. 
This can be useful especially in settings with few labeled examples; e.g. DisC outperform BonG on the Stanford Sentiment Treebank (SST) task, which has only 6,000 labeled examples. 
DisC embeddings also beat SIF and a standard LSTM-based method, Skipthoughts. 
On the much larger IMDB testbed, BonG still reigns at top (although DisC is not too far behind).&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/clfperf_sst_imdb.png&quot; width=&quot;70%&quot; alt=&quot;Performance on SST and IMDB&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Skip-thoughts does match or beat our DisC embeddings on some other classification tasks, but that’s still not too shabby an outcome for such a simple method.  (By contrast, LSTM methods can take days or weeks of training, and are quite slow to evaluate at test time on a new piece of text.)&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/sentenceembedtable.jpg&quot; width=&quot;70%&quot; alt=&quot;Performance on various classification tasks&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;some-theoretical-analysis-via-compressed-sensing&quot;&gt;Some theoretical analysis via compressed sensing&lt;/h2&gt;

&lt;p&gt;A linear SIF-like embedding represents a document with Bag-of-Words vector $x$ as 
&lt;script type=&quot;math/tex&quot;&gt;\sum_w \alpha_w x_w v_w,&lt;/script&gt;
where $v_w$ is the embedding of word $w$ and $\alpha_w$ is a scaling term. 
In other words, it represents document $x$ as $A x$ where $A$ is the matrix with as many columns as the number of words in the language, and the column corresponding to word $w$ is $\alpha_w A$. 
Note that $x$ has many zero coordinates corresponding to words that don’t occur in the document; in other words it’s a &lt;em&gt;sparse&lt;/em&gt; vector.&lt;/p&gt;

&lt;p&gt;The starting point of our DisC work was the realization that perhaps the reason SIF-like embeddings work reasonably well is that they &lt;em&gt;preserve&lt;/em&gt; the Bag-of-words information, in the sense that it may be possible to &lt;em&gt;easily recover&lt;/em&gt; $x$ from $A$. 
This is not an outlandish conjecture at all, because &lt;a href=&quot;https://en.wikipedia.org/wiki/Compressed_sensing&quot;&gt;&lt;em&gt;compressed sensing&lt;/em&gt;&lt;/a&gt; does exactly this when $x$ is suitably sparse and matrix $A$ has some nice properties such as RIP or incoherence. 
A classic example is when $A$ is a random matrix, which in our case corresponds to using random vectors as word embeddings.
Thus one could try to use random word embeddings instead of GloVe vectors in the construction and see what happens! 
Indeed, we find that so long as we raise the dimension of the word embeddings, then text embeddings using random vectors do indeed converge to the performance of BonG representations.&lt;/p&gt;

&lt;p&gt;This is a surprising result, as compressed sensing does not imply this per se, since the ability to reconstruct the BoW vector from its compressed version doesn’t directly imply that the compressed version gives the same performance as BoW on linear classification tasks. 
However, a result of &lt;a href=&quot;https://pdfs.semanticscholar.org/627c/14fe9097d459b8fd47e8a901694198be9d5d.pdf&quot;&gt;Calderbank, Jafarpour, &amp;amp; Schapire&lt;/a&gt; shows that the compressed sensing condition that implies optimal recovery also implies good performance on linear classification under compression. Intuitively, this happens because of two facts.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\mbox{1) Optimum linear classifier $c^*$ is convex combination of datapoints.} \quad c^* = \sum_{i}\alpha_i x_i.&lt;/script&gt; 
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\mbox{(2) RIP condition implies}  &lt;Ax, Ax'&gt; \approx &lt;x, x'&gt;~\mbox{for $k$-sparse}~x, x'. %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Furthermore, by extending these ideas to the $n$-gram case, we show that our DisC embeddings computed using random word vectors, which can be seen as a linear compression of the BonG representation, can do as well as the original BonG representation on linear classification tasks. To do this we prove that the “sensing” matrix $A$ corresponding to DisC embeddings satisfy the  &lt;em&gt;Restricted Isometry Property (RIP)&lt;/em&gt; introduced in the seminal paper of &lt;a href=&quot;https://statweb.stanford.edu/~candes/papers/DecodingLP.pdf&quot;&gt;Candes &amp;amp; Tao&lt;/a&gt;. The theorem relies upon &lt;a href=&quot;http://www.cis.pku.edu.cn/faculty/vision/zlin/A%20Mathematical%20Introduction%20to%20Compressive%20Sensing.pdf&quot;&gt;compressed sensing results for bounded orthonormal systems&lt;/a&gt; and says that then the performance of DisC embeddings on linear classification tasks approaches that of BonG vectors as we increase the dimension. 
Please see our paper for details of the proof.&lt;/p&gt;

&lt;p&gt;It is worth noting that our idea of composing objects (words) represented by random vectors to embed structures ($n$-grams/documents) is closely related to ideas in neuroscience and neural coding proposed by  &lt;a href=&quot;http://www2.fiit.stuba.sk/~kvasnicka/CognitiveScience/6.prednaska/plate.ieee95.pdf&quot;&gt;Tony Plate&lt;/a&gt; and &lt;a href=&quot;http://www.rctn.org/vs265/kanerva09-hyperdimensional.pdf&quot;&gt;Pentti Kanerva&lt;/a&gt;.
They also were interested in how these objects and structures could be recovered from the representations;
we take the further step of relating the recoverability to performance on a downstream linear classification task.
Text classification over compressed BonG vectors has been proposed before by &lt;a href=&quot;https://papers.nips.cc/paper/4932-compressive-feature-learning.pdf&quot;&gt;Paskov, West, Mitchell, &amp;amp; Hastie&lt;/a&gt;, albeit with a more complicated compression that does not achieve a low-dimensional representation (dimension &amp;gt;100,000) due to the use of classical lossless algorithms rather than linear projection.
Our work ties together these ideas of composition and compression into a simple text representation method with provable guarantees.&lt;/p&gt;

&lt;h2 id=&quot;a-surprising-lower-bound-on-the-power-of-lstm-based-text-representations&quot;&gt;A surprising lower bound on the power of LSTM-based text representations&lt;/h2&gt;

&lt;p&gt;The above result also leads to a new theorem about deep learning: &lt;em&gt;text embeddings computed using low-memory LSTMs can do at least as well as BonG representations on downstream classification tasks&lt;/em&gt;.
At first glance this result may seem uninteresting: surely it’s no surprise that the field’s latest and greatest method is at least as powerful as its oldest? 
But in practice, most papers on LSTM-based text embeddings make it a point to compare to performance of BonG baseline, and &lt;em&gt;often are unable to improve upon that baseline&lt;/em&gt;! 
Thus empirically this new theorem had not been clear at all! (One reason could be that our theory requires the random embeddings to be somewhat higher dimensional than the LSTM work had considered.)&lt;/p&gt;

&lt;p&gt;The new theorem follows from considering an LSTM that uses random vectors as word embeddings and computes the DisC embedding in one pass over the text. (For details see our appendix.)&lt;/p&gt;

&lt;p&gt;We empirically tested the effect of dimensionality by measuring performance of DisC on IMDb sentiment classification.
As our theory predicts, the accuracy of DisC using random word embeddings converges to that of BonGs as dimensionality increases. (In the figure below “Rademacher vectors” are those with entries drawn randomly from $\pm1$.) Interestingly we also find that DisC using pretrained word embeddings like GloVe reaches BonG performance at much smaller dimensions, an unsurprising but important point that we will discuss next.&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/imdbperf_uni_bi.png&quot; width=&quot;60%&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;unexplained-mystery-higher-performance-of-pretrained-word-embeddings&quot;&gt;Unexplained mystery: higher performance of pretrained word embeddings&lt;/h2&gt;

&lt;p&gt;While compressed sensing theory is a good starting point for understanding the power of linear text embeddings, it leaves some mysteries. 
Using pre-trained embeddings (such as GloVe) in DisC gives higher performance than random embeddings, both in recovering the BonG information out of the text embedding, as well as in downstream tasks. However, pre-trained embeddings do not satisfy some of the nice properties assumed in compressed sensing theory such as RIP or incoherence, since those properties forbid pairs of words having similar  embeddings.&lt;/p&gt;

&lt;p&gt;Even though the matrix of embeddings does not satisfy these classical compressed sensing properties, we find that using Basis Pursuit, a sparse recovery approach related to LASSO with provable guarantees for RIP matrices, we can recover Bag-of-Words information better using GloVe-based text embeddings than from embeddings using random word vectors (measuring success via the $F_1$-score of the recovered words — higher is better).&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/recovery.png&quot; width=&quot;60%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Note that random embeddings are better than pretrained embeddings at recovering words from random word salad (the right-hand image).
This suggests that pretrained embeddings are specialized — thanks to their training on a text corpus — to do well only on real text rather than a random collection of words.
It would be nice to give a mathematical explanation for this phenomenon. 
We suspect that this should be possible using a result of &lt;a href=&quot;http://www.pnas.org/content/pnas/102/27/9446.full.pdf&quot;&gt;Donoho &amp;amp; Tanner&lt;/a&gt;, which we use to show that words in a document can be recovered from the sum of word vectors if and only if there is a hyperplane containing the vectors for words in the document with the vectors for all other words on one side of it.
Since co-occurring words will have similar embeddings, that should make it easier to find such a hyperplane separating words in a document from the rest of the words and hence would ensure good recovery.&lt;/p&gt;

&lt;p&gt;However, even if this could be made more rigorous, it would only imply sparse recovery, not good performance on classification tasks.
Perhaps assuming a generative model for text, like the RandWalk model discussed in an &lt;a href=&quot;https://www.offconvex.org/2016/02/14/word-embeddings-2/&quot;&gt;earlier post&lt;/a&gt;, could help move this theory forward.&lt;/p&gt;

&lt;h2 id=&quot;discussion&quot;&gt;Discussion&lt;/h2&gt;

&lt;p&gt;Could we improve the performance of such simple embeddings even further? 
One promising idea is to define better $n$-gram embeddings than the simple compositional embeddings defined in DisC. 
An independent &lt;a href=&quot;https://arxiv.org/abs/1703.02507&quot;&gt;NAACL’18 paper&lt;/a&gt; of Pagliardini, Gupta, &amp;amp; Jaggi proposes a text embedding similar to DisC in which unigram and bigram embeddings are trained specifically to be added together to form sentence embeddings, also achieving good results, albeit not as good as DisC. 
(Of course, their training time is higher than ours.) 
In our upcoming &lt;a href=&quot;https://arxiv.org/abs/1805.05388&quot;&gt;ACL’18 paper&lt;/a&gt; with Yingyu Liang, Tengyu Ma, &amp;amp; Brandon Stewart we give a very simple and efficient method to induce embeddings for $n$-grams as well as other rare linguistic features that improves upon DisC and beats skipthought on several other benchmarks. 
This will be described in a future blog post.&lt;/p&gt;

&lt;p&gt;Sample code for constructing and evaluating DisC embeddings is &lt;a href=&quot;https://github.com/NLPrinceton/text_embedding&quot;&gt;available&lt;/a&gt;, as well as &lt;a href=&quot;https://github.com/NLPrinceton/sparse_recovery&quot;&gt;solvers&lt;/a&gt; for recreating the sparse recovery results for word embeddings.&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jun 2018 03:00:00 -0700</pubDate>
        <link>http://localhost:4000/2018/06/25/textembeddings/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/25/textembeddings/</guid>
      </item>
     
    
     
      <item>
        <title>Deep-learning-free Text and Sentence Embedding, Part 1</title>
        <description>&lt;p&gt;Word embeddings (see my old &lt;a href=&quot;http://www.offconvex.org/2015/12/12/word-embeddings-1/&quot;&gt;post1&lt;/a&gt;  and 
&lt;a href=&quot;http://www.offconvex.org/2016/02/14/word-embeddings-2/&quot;&gt;post2&lt;/a&gt;) capture the idea that one can express “meaning” of words using a vector, so that the cosine of the angle between the vectors captures semantic similarity. (“Cosine similarity” property.) Sentence embeddings and text embeddings try to achieve  something similar: use a fixed-dimensional vector to represent a small piece of text, say a sentence or a small paragraph. The performance of such embeddings can be tested via the Sentence Textual Similarity (STS) datasets (see the &lt;a href=&quot;http://ixa2.si.ehu.es/stswiki/index.php/Main_Page&quot;&gt;wiki page&lt;/a&gt;), which contain sentence pairs humanly-labeled with similarity ratings.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/textembeddingvectorslide.jpg&quot; width=&quot;30%&quot; alt=&quot;What are text embeddings.&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;A general hope behind computing text embeddings is that they can be learnt using a large &lt;em&gt;unlabeled&lt;/em&gt; text corpus (similar to word embeddings) and then allow good performance on downstream classification tasks with few &lt;em&gt;labeled&lt;/em&gt; examples. Thus the overall pipeline could look like this:&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/textembeddingpipeline.jpg&quot; width=&quot;80%&quot; alt=&quot;How are text embeddings used in downstream classification task.&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Computing such representations is a form of &lt;a href=&quot;http://www.offconvex.org/2017/06/26/unsupervised1/&quot;&gt;representation learning as well as unsupervised learning&lt;/a&gt;. This post will be an introduction to &lt;strong&gt;extremely simple&lt;/strong&gt; ways of computing sentence embeddings, which on many standard tasks, beat many state-of-the-art  deep learning methods. This post is based upon &lt;a href=&quot;https://openreview.net/pdf?id=SyK00v5xx&quot;&gt;my ICLR’17 paper on SIF embeddings&lt;/a&gt; with Yingyu Liang and Tengyu Ma.&lt;/p&gt;

&lt;h2 id=&quot;existing-methods&quot;&gt;Existing methods&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2133826&quot;&gt;Topic modeling&lt;/a&gt; is a classic technique for unsupervised learning on text and it also yields a vector representation for a paragraph (or longer document), specifically, the vector of “topics” occuring in this document and their relative proportions. Unfortunately, topic modeling is not accurate at producing good representations at the sentence or short paragraph level, and furthermore there appears to be no variant of topic modeling that leads to the good cosine similarity property that we desire.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Recurrent neural net&lt;/em&gt; is the default  deep learning technique  to train a &lt;a href=&quot;https://www.tensorflow.org/tutorials/recurrent&quot;&gt;language model&lt;/a&gt;. It scans the text from left to right, maintaining a fixed-dimensional vector-representation of the text it has seen so far. It’s goal is to use this representation to predict the next word at each time step, and the training objective is to maximise log-likelihood of the data (or similar). Thus for example, a well-trained model when given a text fragment &lt;em&gt;“I went to the cafe and ordered a ….”&lt;/em&gt;   would assign high probability to &lt;em&gt;“coffee”, “croissant”&lt;/em&gt; etc. and low probability to  &lt;em&gt;“puppy”&lt;/em&gt;. Myriad variations of such language models exist, many using biLSTMs which have some long-term memory and can scan the text forward and backwards. Lately biLSTMs have been replaced by convolutional architectures with attention mechanism; see for instance &lt;a href=&quot;http://papers.nips.cc/paper/7181-attention-is-all-you-need.pdf&quot;&gt;this paper&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One obtains a text representation by peeking at the internal representation (i.e., node activations) at the top layer of this deep model. After all, when the model is scanning through text, its ability to predict  the next word must imply that this internal representation implicitly captures a gist of all it has seen, reflecting rules of grammar, common-sense etc. (e.g., that you don’t order a puppy at a cafe). Some notable modern efforts along such lines are &lt;a href=&quot;https://arxiv.org/abs/1506.01057&quot;&gt;Hierarchichal Neural Autoencoder of Li et al.&lt;/a&gt; as well as &lt;a href=&quot;https://arxiv.org/abs/1502.06922&quot;&gt;Palangi et al&lt;/a&gt;, and  &lt;a href=&quot;https://arxiv.org/abs/1506.06726&quot;&gt;&lt;em&gt;Skipthought&lt;/em&gt; of Kiros et al.&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As with all deep learning models, one wishes for interpretability: what information exactly did the machine choose to put into the text embedding? Besides &lt;a href=&quot;https://people.csail.mit.edu/beenkim/papers/BeenK_FinaleDV_ICML2017_tutorial.pdf&quot;&gt;the usual reasons for seeking interpretability&lt;/a&gt;, in an NLP context it may help us leverage  additional external resources such as &lt;a href=&quot;https://wordnet.princeton.edu/&quot;&gt;WordNet&lt;/a&gt; in the task. Other motivations include
 transfer learning/domain adaptation (to solve classification tasks for a  small text corpus, leverage text embeddings trained on a large unrelated corpus).&lt;/p&gt;

&lt;h2 id=&quot;surprising-power-of-simple-linear-representations&quot;&gt;Surprising power of simple linear representations&lt;/h2&gt;

&lt;p&gt;In practice, many NLP applications rely on a simple sentence embedding: the average of the embeddings of the words in it. This makes some intuitive sense, because recall that the &lt;a href=&quot;https://arxiv.org/pdf/1310.4546.pdf&quot;&gt;Word2Vec paper&lt;/a&gt; uses  the following expression (in the their simpler CBOW word embedding)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Pr[w~|~w_1,w_2, w_3, w_4, w_5] \propto \exp(v_w \cdot (\frac{1}{5} \sum_i v_{w_i}). \qquad  (1)&lt;/script&gt;

&lt;p&gt;which suggests that the sense of a sequence of words is captured via simple average of word vectors.&lt;/p&gt;

&lt;p&gt;While this simple average has only fair performance in capturing sentence similarity via cosine similarity, it can be quite powerful in downstream classification tasks (after passing through a single layer neural net)   as shown in a 
 surprising paper of &lt;a href=&quot;https://arxiv.org/abs/1511.08198&quot;&gt;Wieting et al. ICLR’16&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;better-linear-representation-sif-embeddings&quot;&gt;Better linear representation: SIF embeddings&lt;/h2&gt;

&lt;p&gt;My &lt;a href=&quot;https://openreview.net/pdf?id=SyK00v5xx&quot;&gt;ICLR’17 paper&lt;/a&gt; with Yingyu Liang and Tengyu Ma improved such simple averaging  using our &lt;strong&gt;SIF&lt;/strong&gt; embeddings. They’re motivated by the empirical observation that word embeddings have various pecularities stemming from the training method, which tries to capture word cooccurence probabilities using vector inner product, and words sometimes occur out of context in documents. These anomalies cause the average of word vectors to have nontrivial components along semantically meaningless directions. SIF embeddings try to combat this in two ways, which I describe intuitively first, followed by more theoretical justification.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Idea 1: Nonuniform weighting of words.&lt;/strong&gt;
Conventional wisdom in information retrieval holds that “frequent words carry less signal.” Usually this is captured via &lt;a href=&quot;https://en.wikipedia.org/wiki/Tf%E2%80%93idf&quot;&gt;TF-IDF weighting&lt;/a&gt;, which assigns weightings to words inversely proportional to their frequency. We introduce a new variant we call &lt;em&gt;Smoothed Inverse Frequency&lt;/em&gt; (SIF) weighting, 
 which assigns to word $w$ a weighting $\alpha_w = a/(a+ p_w)$ where $p_w$ is the frequency of $w$ in the corpus and $a$ is a hyperparameter. Thus the embedding of a piece of text is $\sum_w \alpha_w v_w$ where the sum is over words in it. 
 (Aside: word frequencies can be estimated from any sufficiently large corpus; we find embedding quality to be not too dependent upon this.)&lt;/p&gt;

&lt;p&gt;On a related note, we found that  folklore understanding of word2vec, viz., expression (1), is &lt;em&gt;false.&lt;/em&gt;  A dig into the code reveals a resampling trick that is tantamount to a weighted average quite similar to our SIF weighting. (See Section 3.1 in our paper for a discussion.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Idea 2: Remove component from top singular direction.&lt;/strong&gt;
  The next idea is to modify the above weighted average by removing the component in a special direction, corresponding to the   top   singular direction set of weighted embeddings of a smallish sample of sentences from the domain (if doing domain adaptation, component is computed using sentences of the target domain). The paper notes that the direction corresponding to the top singular vector tends to contain information related to grammar and stop words, and removing the component in this subspace really cleans up the text embedding’s ability to express meaning.&lt;/p&gt;

&lt;h2 id=&quot;theoretical-justification&quot;&gt;Theoretical justification&lt;/h2&gt;
&lt;p&gt;A notable part of our paper is to give a theoretical justification for this weighting using a generative model for text similar to one used in our &lt;a href=&quot;http://aclweb.org/anthology/Q16-1028&quot;&gt;word embedding paper in TACL’16&lt;/a&gt; as described in &lt;a href=&quot;http://www.offconvex.org/2016/02/14/word-embeddings-2/&quot;&gt;my old post&lt;/a&gt;.
  That model tries to give the causative relationship between word meanings and their cooccurence probabilities.  It  thinks of corpus generation as a dynamic process, where the $t$-th word is produced at step $t$. The model says that the process is driven by the random walk of a &lt;em&gt;discourse&lt;/em&gt; vector $c_t \in \Re^d$. It is a unit vector whose direction in space represents &lt;em&gt;what is being talked about.&lt;/em&gt;
 Each word has a  (time-invariant) latent vector $v_w \in \Re^d$ that captures its correlations with the discourse vector. We model this bias with a loglinear word production model:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Pr[w~\mbox{emitted at time $t$}~|~c_t] \propto \exp(c_t\cdot v_w). \qquad (2)&lt;/script&gt;

&lt;p&gt;The discourse vector does a slow geometric random walk over the unit sphere in $\Re^d$. Thus $c_{t+1}$ is obtained by a small random displacement from $c_t$. Since expression (2) places much higher probability on words that are clustered around $c_t$, and  $c_t$ moves slowly. If the discourse vector moves slowly, then we can assume a single discourse vector gave rise to the entire sentence or short paragraph. Thus given a sentence, a plausible vector representation of its “meaning” is a  &lt;em&gt;max a posteriori&lt;/em&gt; (MAP) estimate of the discourse vector that generated it.&lt;/p&gt;

&lt;p&gt;Such models have been empirically studied for a while, but our paper gave a theoretical analysis, and showed that various subcases imply standard word embedding methods such as word2vec and GloVe. For example, it shows that MAP estimate of the discourse vector is the simple average of the embeddings of the preceding $k$ words – in other words,  the average word vector!&lt;/p&gt;

&lt;p&gt;This  model is clearly simplistic and our ICLR’17 paper suggests two correction terms, intended to account for words occuring out of context, and to allow some  common words  (&lt;em&gt;“the”, “and”, “but”&lt;/em&gt; etc.) appear often regardless of the discourse. We first introduce an  additive term $\alpha p(w)$ in the log-linear model, where $p(w)$ is the unigram probability (in the entire corpus) of word and $\alpha$ is a scalar. This allows words to occur even if their vectors have very low inner products with $c_s$. 
  Secondly, we introduce a common discourse vector $c_0\in \Re^d$ which serves as a correction term for the most frequent discourse that is often related to syntax. It boosts the co-occurrence probability of words that have a high component along $c_0$.(One could make other correction terms, which are left to future work.) To put it another way, words that need to appear a lot out of context can do so by having a component along $c_0$, and the size of this component controls its probability of appearance out of context.&lt;/p&gt;

&lt;p&gt;Concretely, given the discourse vector $c_s$ that produces sentence $s$, the probability of a word $w$ is emitted in the sentence $s$  is modeled as follows, where $\tilde{c}_{s}  = \beta c_0 + (1-\beta) c_s, c_0 \perp c_s$,
  $\alpha$ and $\beta$ are scalar hyperparameters:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\Pr[w \mid s]  = \alpha p(w) + (1-\alpha) \frac{\exp(&lt;\tilde{c}_{s}, v_w&gt;)}{Z_{\tilde{c,s}}}, %]]&gt;&lt;/script&gt;

&lt;p&gt;where&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Z_{\tilde{c,s}} = \sum_{w} \exp(&lt;\tilde{c}_{s}, v_w&gt;) %]]&gt;&lt;/script&gt;

&lt;p&gt;is the normalizing constant (the partition function). We see that the model allows a word $w$ unrelated to the discourse $c_s$ to be emitted for two reasons: a) by chance from the term $\alpha p(w)$; b) if $w$ is correlated with the common direction $c_0$.&lt;/p&gt;

&lt;p&gt;The paper shows that the MAP estimate of the $c_s$ vector corresponds to the SIF embeddings described earlier, where the top singular vector used in their construction is an estimate of the $c_0$ vector in the model.&lt;/p&gt;

&lt;h2 id=&quot;empirical-performance&quot;&gt;Empirical performance&lt;/h2&gt;

&lt;p&gt;The performance of this embedding scheme appears in the figure below. Note that Wieting et al. had already shown that their method (which is semi-supervised, relying upon a large unannotated corpus and a small annotated corpus) beats many LSTM-based methods. So this table only compares to their work; see the papers for comparison with more past work.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/textembedexperiments.jpg&quot; width=&quot;80%&quot; alt=&quot;Performance of our embedding on downstream classification tasks&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;For other performance results please see the paper.&lt;/p&gt;

&lt;h2 id=&quot;next-post&quot;&gt;Next post&lt;/h2&gt;

&lt;p&gt;In the next post, I will sketch improvements to the above embedding in two of our new papers. Special guest appearance: Compressed Sensing (aka Sparse Recovery).&lt;/p&gt;

&lt;p&gt;The SIF embedding package is available &lt;a href=&quot;https://github.com/PrincetonML/SIF&quot;&gt;from our github page&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 17 Jun 2018 03:00:00 -0700</pubDate>
        <link>http://localhost:4000/2018/06/17/textembeddings/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/17/textembeddings/</guid>
      </item>
     
    
     
      <item>
        <title>Limitations of Encoder-Decoder GAN architectures</title>
        <description>&lt;p&gt;This is yet another post about &lt;a href=&quot;http://www.offconvex.org/2017/03/15/GANs/&quot;&gt;Generative Adversarial Nets (GANs)&lt;/a&gt;, and based upon our new &lt;a href=&quot;https://openreview.net/forum?id=BJehNfW0-&quot;&gt;ICLR’18 paper&lt;/a&gt; with Yi Zhang.  A quick recap of the story so far. GANs are an unsupervised method in deep learning to learn interesting distributions (e.g., images of human faces), and also have a plethora of uses for image-to-image mappings in computer vision. Standard GANs training is motivated using this task of distribution learning, and is designed with the idea that given large enough deep nets and enough training examples, as well as accurate optimization, GANs will learn the full distribution.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.offconvex.org/2017/03/30/GANs2/&quot;&gt;Sanjeev’s previous post&lt;/a&gt; concerned &lt;a href=&quot;https://arxiv.org/abs/1703.00573&quot;&gt;his co-authored ICML’17 paper&lt;/a&gt; which called this intuition into question when the deep nets have finite capacity. It shows that the training objective has near-equilibria where the discriminator is fooled —i.e., training objective is good—but the generator’s distributions has very small support, i.e. shows &lt;em&gt;mode collapse.&lt;/em&gt;  This is a failure of the model, and raises the question whether such bad equilibria are found in real-life training. A &lt;a href=&quot;http://www.offconvex.org/2017/07/07/GANs3/&quot;&gt;second post&lt;/a&gt; showed empirical evidence that they do, using the birthday-paradox test.&lt;/p&gt;

&lt;p&gt;The current post concerns our &lt;a href=&quot;https://arxiv.org/abs/1711.02651&quot;&gt;new result&lt;/a&gt; (part of our upcoming &lt;a href=&quot;https://openreview.net/forum?id=BJehNfW0-&quot;&gt;ICLR paper&lt;/a&gt;) which shows that bad equilibria exist also in more recent GAN architectures based on simultaneously learning an &lt;em&gt;encoder&lt;/em&gt; and &lt;em&gt;decoder&lt;/em&gt;. This should be surprising because many researchers believe that encoder-decoder architectures fix many issues with GANs, including mode collapse.&lt;/p&gt;

&lt;p&gt;As we will see, encoder-decoder GANs seem very powerful. In particular, the proof of the previously mentioned &lt;a href=&quot;http://www.offconvex.org/2017/03/30/GANs2/&quot;&gt;negative result&lt;/a&gt; utterly breaks down for this architecture. But, we then discovered a cute argument that shows encoder-decoder GANs can have poor solutions, featuring not only mode collapse but also encoders that map images to nonsense (more precisely Gaussian noise). This is the worst possible failure of the model one could imagine.&lt;/p&gt;

&lt;h2 id=&quot;encoder-decoder-architectures&quot;&gt;Encoder-decoder architectures&lt;/h2&gt;

&lt;p&gt;Encoders and decoders have long been around in machine learning in various forms – especially deep learning. Speaking loosely, underlying all of them are two basic assumptions: &lt;br /&gt;
(1) Some form of the so-called &lt;a href=&quot;https://mitpress.mit.edu/sites/default/files/titles/content/9780262033589_sch_0001.pdf&quot;&gt;&lt;em&gt;manifold assumption&lt;/em&gt;&lt;/a&gt; which asserts that high-dimensional data such as real-life images lie (roughly) on a low-dimensional manifold. (“Manifold” should be interpreted rather informally – sometimes this intuition applies only very approximately sometimes it’s meant in a “distributional” sense, etc.)  &lt;br /&gt;
(2) The low-dimensional structure is “meaningful”: if we think of an image $x$ as a high-dimensional vector and its “code” $z$ as its coordinates on the low-dimensional manifold, the code $z$ is thought of as a “high-level” descriptor of the image.&lt;/p&gt;

&lt;p&gt;With the above two points in mind, an &lt;em&gt;encoder&lt;/em&gt; maps the image to its code, and a &lt;em&gt;decoder&lt;/em&gt; computes the reverse map. (We also discussed encoders and decoders in &lt;a href=&quot;http://www.offconvex.org/2017/06/27/unsupervised1/&quot;&gt;our earlier post on representation learning&lt;/a&gt; in a more general setup.)&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/BIGAN_manifold2.jpg&quot; width=&quot;80%&quot; alt=&quot;Manifold structure&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;encoder-decoder-gans&quot;&gt;Encoder-Decoder GANs&lt;/h2&gt;
&lt;p&gt;These were introduced by &lt;a href=&quot;https://arxiv.org/abs/1606.00704&quot;&gt;Dumoulin et al.(ALI)&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1605.09782&quot;&gt;Donahue et al.(BiGAN)&lt;/a&gt;. They involve two competitors: Player 1 involves a discriminator net $D$ that is given an input of the form (image, code) and it outputs a number in the interval $[0,1]$, which denotes its “satisfaction level” with this input. Player 2 trains a decoder net $G$ (also called &lt;em&gt;generator&lt;/em&gt; in the GANs setting) and an encoder net $E$.&lt;/p&gt;

&lt;p&gt;Recall that in the standard GAN, discriminator tries to distinguish real images from images generated by the generator $G$. Here 
discriminator’s input is an image and its code. Specifically, Player 1 is trying to train its net to distinguish between the following two settings, and Player 2 is trying to make sure the two settings look indistinguishable to Player 1’s net.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\mbox{Setting 1: presented with}~(x, E(x))~\mbox{where $x$ is random real image}.&lt;/script&gt;
&lt;script type=&quot;math/tex&quot;&gt;\mbox{Setting 2: presented with}~(G(z), z)~\mbox{where $z$ is random code}.&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;(Here it is assumed that a random code is a vector with i.i.d gaussian coordinates, though one could consider other distributions.)&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/BIGAN_2settings_v2.jpg&quot; width=&quot;80%&quot; alt=&quot;Two settings which discriminator net has to distinguish between&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;The hoped-for equilibrium obviously is one where generator and encoder are inverses of each other: $E(G(z)) \approx z$ and $G(E(x)) \approx x$, and the joint distributions $(z,G(z))$ and $(E(x), x)$ roughly match.
The underlying intuition is that if this happens, Player 1 must’ve produced a “meaningful” representation $E(x)$ for the images – and this should improve the quality of the generator as well. 
Indeed, &lt;a href=&quot;https://arxiv.org/abs/1606.00704&quot;&gt;Dumoulin et al.(ALI)&lt;/a&gt; provide some small-scale empirical examples on mixtures of Gaussians for which encoder-decoder architectures seem to ameliorate the problem of mode collapse.&lt;/p&gt;

&lt;p&gt;The above papers prove that when the encoder/decoder/discriminator have infinite capacity, the desired solution is indeed an equilibrium. However, we’ll see that things are very different when capacities are finite.&lt;/p&gt;

&lt;h2 id=&quot;finite-capacity-discriminators-are-weak&quot;&gt;Finite-capacity discriminators are weak&lt;/h2&gt;

&lt;p&gt;Say a generator/encoder pair $(G,E)$ $\epsilon$-&lt;em&gt;fools&lt;/em&gt; a decoder $D$ if&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;|E_{x} D(x, E(x)) - E_{z} D(G(z), z)| \leq \epsilon&lt;/script&gt;

&lt;p&gt;In other words, $D$ has roughly similar output in Settings 1 and 2.&lt;/p&gt;

&lt;p&gt;Our theorem applies when the distribution consists of realistic images, as explained later. We show the following:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(Informal theorem) If the discriminator $D$ has capacity (i.e. number of parameters) at most $p$, then there is an encoder $E$ of capacity $\ll p$ and  generator $G$ of slightly larger capacity than $p$ such that $(G, E)$ can $\epsilon$-fool every such $D$. Furthermore, the generator exhibits mode collapse: its distribution is essentially supported on a bit more than $p$ images, and the encoder $E$ just outputs white noise (i.e. does not extract any “meaningful” representation) given an image.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(Note that such a $(G, E)$ represents an $\epsilon$-approximate equilibrium, in the sense that player 1 cannot gain more than $\epsilon$ in the distinguishing probability by switching its discriminator. )&lt;/p&gt;

&lt;p&gt;It is important that the encoder’s capacity is much less than $p$, and thus the theorem allows a discriminator that is able to simulate $E$ if it needed, and in particular verify for a random seed $z$ that $E(G(z)) \approx z$. The theorem says that even the ability to conduct such a verification cannot give it power to force encoder to produce meaningful codes. This is a counterintuitive aspect of the result. The main difficulty in the proof (which stumped us for a bit) was how to exhibit such an equilibrium where $E$ is a small net.&lt;/p&gt;

&lt;p&gt;This is ensured by a simple assumption. We assume the image distribution is mildly “noised”: say, every 100th pixel is replaced by Gaussian noise. To a human, such an image would of course be indistinguishable from a real image. (NB: Our proof could be carried out via some other assumptions to the effect that images have an innate stochastic/noise component that is efficiently extractable by a small neural network. But let’s keep things clean.) When noise $\eta$ is thus added to an image $x$, we denote the resulting image as $x \odot \eta$.&lt;/p&gt;

&lt;p&gt;Now the encoder will be rather trivial: given the noised image $x \odot \eta$, output $\eta$. Clearly, such an encoder does not in any sense capture “meaning” in the image. It is also implementable by a tiny single-layer net, as required by the theorem.&lt;/p&gt;

&lt;h3 id=&quot;construction-of-generator&quot;&gt;Construction of generator&lt;/h3&gt;

&lt;p&gt;As usual in the GAN literature, we will assume the discriminator is $L$-&lt;a href=&quot;https://www.encyclopediaofmath.org/index.php/Lipschitz_constant&quot;&gt;Lipschitz&lt;/a&gt;. This can be a loose upperbound, since only $\log L$ enters quantitatively in the proof.&lt;/p&gt;

&lt;p&gt;The generator $G(z)$ in the theorem statement memorizes a hash function that partitions the set of all seeds/codes $z$ into $m$ equal-sized blocks; it also memorizes a “pool” of $m := p \log^2(pL)/ \epsilon^2$ unnoised images $\tilde{x}_1, \tilde{x}_2, \dots, \tilde{x}_m$. When presented with a random seed $z$, the generator computes the block of the partition that $z$ lies in, and then produces the image $\tilde{x}_i \odot z$, where $i$ is the block $z$ belongs to. (See the Figure below.)&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/BIGAN_construction_2.jpg&quot; width=&quot;50%&quot; alt=&quot;The bad generator construction&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Now we have to prove that such a memorizing generator exists that $\epsilon$-fools all discriminators of capacity $p$. This is shown by the &lt;a href=&quot;https://en.wikipedia.org/wiki/Probabilistic_method&quot;&gt;probabilistic method&lt;/a&gt;: we describe a distribution over generators $G$ that works “in expectation”, and subsequently use concentration bounds to prove there exists at least one generator that does the job.&lt;/p&gt;

&lt;p&gt;The distribution on $G$’s is straightforward: we select the pool of (unnoised) images 
$\tilde{x}_1, \tilde{x}_2, .., \tilde{x}_m$ at random. Why is this distribution for $G$ sensible? Notice the following simple fact:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E_{G} E_{z} D(G(z), z) =  E_{\tilde{x}, z} D(\tilde{x} \odot z, z) = E_{x} D(x, E(x)) \hspace{2cm} (3)&lt;/script&gt;

&lt;p&gt;In other words, the “expected” encoder correctly matches the expectation of $D(x, E(x))$, so that the discriminator is fooled “in expectation”.
This of course is not enough: we need some kind of concentration argument to show a particular $G$ works against &lt;em&gt;all possible discriminators&lt;/em&gt;, which will ultimately use the fact that the discriminator $D$ has a small capacity and small Lipschitz constant. (Think covering number arguments in learning theory.)&lt;/p&gt;

&lt;p&gt;Towards that, another useful observation: if $q$ is the uniform distribution over sets $T= {z_1, z_2,\dots, z_m}$, s.t. each $z_i$ is independently sampled from the conditional distribution inside the $i$-th block of the partition of the noise space, by the law of total expectation one can see that 
&lt;script type=&quot;math/tex&quot;&gt;E_{z} D(G(z), z) = E_{T \sim q} \frac{1}{m} \sum_{i=1}^m D(G(z_i), z_i)&lt;/script&gt;
The right hand side is an average of terms, each of which is a bounded function of mutually independent random variables – so, by e.g. McDiarmid’s inequality it concentrates around it’s expectation, which by (3) is exactly $E_{z} D(G(z), z)$.&lt;/p&gt;

&lt;p&gt;To finish the argument off, we use the fact that due to Lipschitzness and the bound on the number of parameters, the “effective” number of distinct discriminators is small, so we can union bound over them. (Formally, this translates to an epsilon-net + union bound argument. This also gives rise to the value of $m$ used in the construction.)&lt;/p&gt;

&lt;h2 id=&quot;takeaway&quot;&gt;Takeaway&lt;/h2&gt;

&lt;p&gt;The result should be interpreted as saying that possibly the theoretical foundations of GANs need more work. The current way of thinking about them as distribution learners may not be the right way to formalize them. Furthermore, one has to take care about transfering notions invented for distribution learning, such as encoders and decoders, over into the GANs setting. Finally there is an empirical question whether any of the &lt;a href=&quot;https://deephunt.in/the-gan-zoo-79597dc8c347&quot;&gt;myriad GANS variations&lt;/a&gt; can avoid mode collapse.&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Mar 2018 03:00:00 -0700</pubDate>
        <link>http://localhost:4000/2018/03/12/bigan/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/12/bigan/</guid>
      </item>
     
    
     
      <item>
        <title>Can increasing depth serve to accelerate optimization?</title>
        <description>&lt;p&gt;“How does depth help?” is a fundamental question in the theory of deep learning. Conventional wisdom, backed by theoretical studies (e.g. &lt;a href=&quot;http://proceedings.mlr.press/v49/eldan16.pdf&quot;&gt;Eldan &amp;amp; Shamir 2016&lt;/a&gt;; &lt;a href=&quot;http://proceedings.mlr.press/v70/raghu17a/raghu17a.pdf&quot;&gt;Raghu et al. 2017&lt;/a&gt;; &lt;a href=&quot;http://proceedings.mlr.press/v65/lee17a/lee17a.pdf&quot;&gt;Lee et al. 2017&lt;/a&gt;; &lt;a href=&quot;http://proceedings.mlr.press/v49/cohen16.pdf&quot;&gt;Cohen et al. 2016&lt;/a&gt;; &lt;a href=&quot;http://proceedings.mlr.press/v65/daniely17a/daniely17a.pdf&quot;&gt;Daniely 2017&lt;/a&gt;; &lt;a href=&quot;https://openreview.net/pdf?id=B1J_rgWRW&quot;&gt;Arora et al. 2018&lt;/a&gt;), holds that adding layers increases expressive power. But often this expressive gain comes at a price –optimization is harder for deeper networks (viz., &lt;a href=&quot;https://en.wikipedia.org/wiki/Vanishing_gradient_problem&quot;&gt;vanishing/exploding gradients&lt;/a&gt;). Recent works on “landscape characterization” implicitly adopt this worldview (e.g. &lt;a href=&quot;https://papers.nips.cc/paper/6112-deep-learning-without-poor-local-minima.pdf&quot;&gt;Kawaguchi 2016&lt;/a&gt;; &lt;a href=&quot;https://openreview.net/pdf?id=ryxB0Rtxx&quot;&gt;Hardt &amp;amp; Ma 2017&lt;/a&gt;; &lt;a href=&quot;http://proceedings.mlr.press/v38/choromanska15.pdf&quot;&gt;Choromanska et al. 2015&lt;/a&gt;; &lt;a href=&quot;http://openaccess.thecvf.com/content_cvpr_2017/papers/Haeffele_Global_Optimality_in_CVPR_2017_paper.pdf&quot;&gt;Haeffele &amp;amp; Vidal 2017&lt;/a&gt;; &lt;a href=&quot;https://arxiv.org/pdf/1605.08361.pdf&quot;&gt;Soudry &amp;amp; Carmon 2016&lt;/a&gt;; &lt;a href=&quot;https://arxiv.org/pdf/1712.08968.pdf&quot;&gt;Safran &amp;amp; Shamir 2017&lt;/a&gt;). They prove theorems about local minima and/or saddle points in the objective of a deep network, while implicitly assuming that the ideal landscape would be convex (single global minimum, no other critical point). My &lt;a href=&quot;https://arxiv.org/pdf/1802.06509.pdf&quot;&gt;new paper&lt;/a&gt;  with Sanjeev Arora and Elad Hazan makes the counterintuitive suggestion that sometimes, increasing depth can &lt;em&gt;accelerate&lt;/em&gt; optimization.&lt;/p&gt;

&lt;p&gt;Our work can also be seen as one more piece of evidence for a nascent belief that &lt;em&gt;overparameterization&lt;/em&gt; of deep nets may be a good thing. By contrast, classical statistics discourages training a model with more parameters than necessary &lt;a href=&quot;https://www.rasch.org/rmt/rmt222b.htm&quot;&gt;as this can lead to overfitting&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;ell_p-regression&quot;&gt;$\ell_p$ Regression&lt;/h2&gt;

&lt;p&gt;Let’s begin by considering a very simple learning problem - scalar linear regression with $\ell_p$ loss (our theory and experiments will apply to $p&amp;gt;2$):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{\mathbf{w}}~L(\mathbf{w}):=\frac{1}{p}\sum_{(\mathbf{x},y)\in{S}}(\mathbf{x}^\top\mathbf{w}-y)^p&lt;/script&gt;

&lt;p&gt;$S$ here stands for a training set, consisting of pairs $(\mathbf{x},y)$ where $\mathbf{x}$ is a vector representing an instance and $y$ is a (numeric) scalar standing for its label; $\mathbf{w}$ is the parameter vector we wish to learn.  Let’s convert the linear model to an extremely simple “depth-2 network”, by replacing the vector $\mathbf{w}$ with a vector $\mathbf{w_1}$ times a scalar $\omega_2$. Clearly, this is an overparameterization that does not change expressiveness, but yields the (non-convex) objective:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{\mathbf{w_1},\omega_2}~L(\mathbf{w_1},\omega_2):=\frac{1}{p}\sum_{(\mathbf{x},y)\in{S}}(\mathbf{x}^\top\mathbf{w_1}\omega_2-y)^p&lt;/script&gt;

&lt;p&gt;We show in the paper, that if one applies gradient descent over $\mathbf{w_1}$ and $\omega_2$, with small learning rate and near-zero initialization (as customary in deep learning), the induced dynamics on the overall (&lt;em&gt;end-to-end&lt;/em&gt;) model $\mathbf{w}=\mathbf{w_1}\omega_2$ can be written as follows:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbf{w}^{(t+1)}\leftarrow\mathbf{w}^{(t)}-\rho^{(t)}\nabla{L}(\mathbf{w}^{(t)})-\sum_{\tau=1}^{t-1}\mu^{(t,\tau)}\nabla{L}(\mathbf{w}^{(\tau)})&lt;/script&gt;

&lt;p&gt;where $\rho^{(t)}$ and $\mu^{(t,\tau)}$ are appropriately defined (time-dependent) coefficients.
Thus the seemingly benign addition of a single multiplicative scalar turned plain gradient descent into a scheme that somehow has a memory of past gradients —the key feature of &lt;a href=&quot;https://distill.pub/2017/momentum/&quot;&gt;momentum&lt;/a&gt; methods— as well as a time-varying learning rate. While theoretical analysis of the precise benefit of momentum methods is never easy, a simple experiment with $p=4$, on &lt;a href=&quot;https://archive.ics.uci.edu/ml/index.php&quot;&gt;UCI Machine Learning Repository&lt;/a&gt;’s &lt;a href=&quot;https://archive.ics.uci.edu/ml/datasets/gas+sensor+array+drift+dataset&quot;&gt;“Gas Sensor Array Drift at Different Concentrations” dataset&lt;/a&gt;, shows the following effect:&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/acc_oprm_L4_exp.png&quot; width=&quot;40%&quot; alt=&quot;L4 regression experiment&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Not only did the overparameterization accelerate gradient descent, but it has done so more than two well-known, explicitly designed acceleration methods – &lt;a href=&quot;http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf&quot;&gt;AdaGrad&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/pdf/1212.5701.pdf&quot;&gt;AdaDelta&lt;/a&gt; (the former did not really provide a speedup in this experiment). We observed similar speedups in other settings as well.&lt;/p&gt;

&lt;p&gt;What is happening here? Can non-convex objectives corresponding to deep networks be easier to optimize than convex ones?
Is this phenomenon common or is it limited to toy problems as above?
We take a first crack at addressing these questions…&lt;/p&gt;

&lt;h2 id=&quot;overparameterization-decoupling-optimization-from-expressiveness&quot;&gt;Overparameterization: Decoupling Optimization from Expressiveness&lt;/h2&gt;

&lt;p&gt;A general study of the effect of depth on optimization entails an inherent difficulty - deeper networks may seem to converge faster due to their superior expressiveness.
In other words, if optimization of a deep network progresses more rapidly than that of a shallow one, it may not be obvious whether this is a result of a true acceleration phenomenon, or simply a byproduct of the fact that the shallow model cannot reach the same loss as the deep one.
We resolve this conundrum by focusing on models whose representational capacity is oblivious to depth - &lt;em&gt;linear neural networks&lt;/em&gt;, the subject of many recent studies.
With linear networks, adding layers does not alter expressiveness; it manifests itself only in the replacement of a matrix parameter by a product of matrices - an overparameterization.
Accordingly, if this leads to accelerated convergence, one can be certain that it is not an outcome of any phenomenon other than favorable properties of depth for optimization.&lt;/p&gt;

&lt;h2 id=&quot;implicit-dynamics-of-depth&quot;&gt;Implicit Dynamics of Depth&lt;/h2&gt;

&lt;p&gt;Suppose we are interested in learning a linear model parameterized by a matrix $W$, through minimization of some training loss $L(W)$.
Instead of working directly with $W$, we replace it by a depth $N$ linear neural network, i.e. we overparameterize it as $W=W_{N}W_{N-1}\cdots{W_1}$, with $W_j$ being weight matrices of individual layers.
In the paper we show that if one applies gradient descent over $W_{1}\ldots{W}_N$, with small learning rate $\eta$, and with the condition:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;W_{j+1}^\top W_{j+1} = W_j W_j^\top&lt;/script&gt;

&lt;p&gt;satisfied at optimization commencement (note that this approximately holds with standard near-zero initialization), the dynamics induced on the overall end-to-end mapping $W$ can be written as follows:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;W^{(t+1)}\leftarrow{W}^{(t)}-\eta\sum_{j=1}^{N}\left[W^{(t)}(W^{(t)})^\top\right]^\frac{j-1}{N}\nabla{L}(W^{(t)})\left[(W^{(t)})^\top{W}^{(t)}\right]^\frac{N-j}{N}&lt;/script&gt;

&lt;p&gt;We validate empirically that this analytically derived update rule (over classic linear model) indeed complies with deep network optimization, and take a series of steps to theoretically interpret it.
We find that the transformation applied to the gradient $\nabla{L}(W)$ (multiplication from the left by $[WW^\top]^\frac{j-1}{N}$, and from the right by $[W^\top{W}]^\frac{N-j}{N}$, followed by summation over $j$) is a particular preconditioning scheme, that promotes movement along directions already taken by optimization.
More concretely, the preconditioning can be seen as a combination of two elements:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;an adaptive learning rate that increases step sizes away from initialization; and&lt;/li&gt;
  &lt;li&gt;a “momentum-like” operation that stretches the gradient along the azimuth taken so far.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An important point to make is that the update rule above, referred to hereafter as the &lt;em&gt;end-to-end update rule&lt;/em&gt;, does not depend on widths of hidden layers in the linear neural network, only on its depth ($N$).
This implies that from an optimization perspective, overparameterizing using wide or narrow networks has the same effect - it is only the number of layers that matters.
Therefore, acceleration by depth need not be computationally demanding - a fact we clearly observe in our experiments (previous figure for example shows acceleration by orders of magnitude at the price of a single extra scalar parameter).&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/acc_oprm_update_rule.png&quot; width=&quot;60%&quot; alt=&quot;End-to-end update rule&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;beyond-regularization&quot;&gt;Beyond Regularization&lt;/h2&gt;

&lt;p&gt;The end-to-end update rule defines an optimization scheme whose steps are a function of the gradient $\nabla{L}(W)$ and the parameter $W$.
As opposed to many acceleration methods (e.g. &lt;a href=&quot;https://distill.pub/2017/momentum/&quot;&gt;momentum&lt;/a&gt; or &lt;a href=&quot;https://arxiv.org/pdf/1412.6980.pdf&quot;&gt;Adam&lt;/a&gt;) that explicitly maintain auxiliary variables, this scheme is memoryless, and by definition born from gradient descent over something (overparameterized objective).
It is therefore natural to ask if we can represent the end-to-end update rule as gradient descent over some regularization of the loss $L(W)$, i.e. over some function of $W$.
We prove, somewhat surprisingly, that the answer is almost always negative - as long as the loss $L(W)$ does not have a critical point at $W=0$, the end-to-end update rule, i.e. the effect of overparameterization, cannot be attained via &lt;em&gt;any&lt;/em&gt; regularizer.&lt;/p&gt;

&lt;h2 id=&quot;acceleration&quot;&gt;Acceleration&lt;/h2&gt;

&lt;p&gt;So far, we analyzed the effect of depth (in the form of overparameterization) on optimization by presenting an equivalent preconditioning scheme and discussing some of its properties.
We have not, however, provided any theoretical evidence in support of acceleration (faster convergence) resulting from this scheme.
Full characterization of the scenarios in which there is a speedup goes beyond the scope of our paper.
Nonetheless, we do analyze a simple $\ell_p$ regression problem, and find that whether or not increasing depth accelerates depends on the choice of $p$:
for $p=2$ (square loss) adding layers does not lead to a speedup (in accordance with previous findings by &lt;a href=&quot;https://arxiv.org/pdf/1312.6120.pdf&quot;&gt;Saxe et al. 2014&lt;/a&gt;);
for $p&amp;gt;2$ it can, and this may be attributed to the preconditioning scheme’s ability to handle large plateaus in the objective landscape.
A number of experiments, with $p$ equal to 2 and 4, and depths ranging between 1 (classic linear model) and 8, support this conclusion.&lt;/p&gt;

&lt;h2 id=&quot;non-linear-experiment&quot;&gt;Non-Linear Experiment&lt;/h2&gt;

&lt;p&gt;As a final test, we evaluated the effect of overparameterization on optimization in a non-idealized (yet simple) deep learning setting - the &lt;a href=&quot;https://github.com/tensorflow/models/tree/master/tutorials/image/mnist&quot;&gt;convolutional network tutorial for MNIST built into TensorFlow&lt;/a&gt;.
We introduced overparameterization by simply placing two matrices in succession instead of the matrix in each dense layer.
With an addition of roughly 15% in number of parameters, optimization accelerated by orders of magnitude:&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/acc_oprm_cnn_exp.png&quot; width=&quot;40%&quot; alt=&quot;TensorFlow MNIST CNN experiment&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;We note that similar experiments on other convolutional networks also gave rise to a speedup, but not nearly as prominent as the above.
Empirical characterization of conditions under which overparameterization accelerates optimization in non-linear settings is potentially an interesting direction for future research.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Our work provides insight into benefits of depth in the form of overparameterization, from the perspective of optimization.
Many open questions and problems remain.
For example, is it possible to rigorously analyze the acceleration effect of the end-to-end update rule (analogously to, say, &lt;a href=&quot;http://www.cis.pku.edu.cn/faculty/vision/zlin/1983-A%20Method%20of%20Solving%20a%20Convex%20Programming%20Problem%20with%20Convergence%20Rate%20O(k%5E(-2))_Nesterov.pdf&quot;&gt;Nesterov 1983&lt;/a&gt; or &lt;a href=&quot;http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf&quot;&gt;Duchi et al. 2011&lt;/a&gt;)?
Treatment of non-linear deep networks is of course also of interest, as well as more extensive empirical evaluation.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cohennadav.com/&quot;&gt;Nadav Cohen&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 02 Mar 2018 05:00:00 -0800</pubDate>
        <link>http://localhost:4000/2018/03/02/acceleration-overparameterization/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/02/acceleration-overparameterization/</guid>
      </item>
     
    
     
      <item>
        <title>Proving generalization of deep nets via compression</title>
        <description>&lt;p&gt;This post is about &lt;a href=&quot;https://arxiv.org/abs/1802.05296&quot;&gt;my new paper with Rong Ge, Behnam Neyshabur, and Yi Zhang&lt;/a&gt; which offers some new perspective into the generalization mystery for deep nets discussed in 
&lt;a href=&quot;http://www.offconvex.org/2017/12/08/generalization1/&quot;&gt;my earlier post&lt;/a&gt;. The new paper introduces an elementary compression-based framework for proving generalization bounds. It shows that deep nets are highly noise stable, and consequently, compressible. The framework also gives easy proofs (sketched below) of some papers that appeared in the past year.&lt;/p&gt;

&lt;p&gt;Recall that the &lt;strong&gt;basic theorem&lt;/strong&gt; of generalization theory says something like this: if training set had $m$ samples then the  &lt;em&gt;generalization error&lt;/em&gt; —defined as the difference between error on training data and  test data (aka held out data)— is of the order of $\sqrt{N/m}$. Here  $N$ is the number of &lt;em&gt;effective parameters&lt;/em&gt; (or &lt;em&gt;complexity measure&lt;/em&gt;) of the net; it is at most the actual number of trainable parameters but could be much less. (For ease of exposition this post will ignore nuisance factors like $\log N$ etc. which also appear in the these calculations.) The mystery is that networks with millions of parameters have low generalization error even when $m =50K$ (as in CIFAR10 dataset), which suggests that the number of true parameters is actually much less than $50K$. The papers  &lt;a href=&quot;https://arxiv.org/abs/1706.08498&quot;&gt;Bartlett et al. NIPS’17&lt;/a&gt; and &lt;a href=&quot;https://openreview.net/forum?id=Skz_WfbCZ&quot;&gt;Neyshabur et al. ICLR’18&lt;/a&gt;
try to quantify the complexity measure using very interesting ideas like Pac-Bayes and Margin (which influenced our paper). But ultimately the quantitative estimates are fairly vacuous  —orders of magnitude &lt;em&gt;more&lt;/em&gt; than the number of &lt;em&gt;actual parameters.&lt;/em&gt;  By contrast our new estimates are several orders of magnitude better, and on the verge of being interesting. See the following bar graph on a log scale. (All bounds are listed  ignoring “nuisance factors.” Number of trainable parameters is included only to indicate scale.)&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/saddle_eff/acompare.png&quot; width=&quot;75%&quot; alt=&quot;comparison of bounds from various recent papers&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;the-compression-approach&quot;&gt;The Compression Approach&lt;/h2&gt;

&lt;p&gt;The compression approach takes a deep net $C$ with $N$ trainable parameters and tries to compress it to another one $\hat{C}$ that has (a) much fewer parameters $\hat{N}$ than $C$ and (b) has roughly the same training error as $C$.&lt;/p&gt;

&lt;p&gt;Then the above basic theorem guarantees that so long as the number of training samples exceeds $\hat{N}$, then $\hat{C}$ &lt;em&gt;does&lt;/em&gt; generalize well (even if $C$ doesn’t).  An extension of this approach says that the same conclusions holds if we let the compression algorithm to depend upon an arbitrarily long &lt;em&gt;random string&lt;/em&gt; provided this string is fixed in advance of seeing the training data. We call this &lt;em&gt;compression with respect to fixed string&lt;/em&gt; and rely upon it.&lt;/p&gt;

&lt;p&gt;Note that the above approach proves good generalization of the compressed $\hat{C}$, not the original $C$. (I suspect the ideas may extend to proving good generalization of the original $C$; the hurdles seem technical rather than inherent.) Something similar was true of earlier approaches using PAC-Bayes bounds, which also  prove the generalization of some  net related to $C$, not of $C$ itself. (Hence the tongue-in-cheek title of the classic reference &lt;a href=&quot;http://www.cs.cmu.edu/~jcl/papers/nn_bound/not_bound.pdf&quot;&gt;Langford-Caruana2002&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Of course, in practice  deep nets are well-known to be compressible using a slew of ideas—by factors of 10x to 100x; see &lt;a href=&quot;https://arxiv.org/abs/1710.09282&quot;&gt;the recent survey&lt;/a&gt;. However, usually such compression involves &lt;em&gt;retraining&lt;/em&gt; the compressed net. Our paper doesn’t consider retraining the net (since it involves reasoning about the loss landscape) but followup work should look at this.&lt;/p&gt;

&lt;h2 id=&quot;flat-minima-and-noise-stability&quot;&gt;Flat minima and Noise Stability&lt;/h2&gt;

&lt;p&gt;Modern generalization results can be seen as proceeding via some formalization of a &lt;em&gt;flat minimum&lt;/em&gt; of the loss landscape. This was suggested in 1990s as the source of good generalization &lt;a href=&quot;http://www.bioinf.jku.at/publications/older/3304.pdf&quot;&gt;Hochreiter and Schmidhuber 1995&lt;/a&gt;. Recent empirical work of &lt;a href=&quot;https://arxiv.org/abs/1609.04836&quot;&gt;Keskar et al 2016&lt;/a&gt; on modern deep architectures finds that flatness does correlate with better generalization, though the issue is complicated, as discussed in an upcoming post by Behnam Neyshabur.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/saddle_eff/aflatminima.png&quot; width=&quot;65%&quot; alt=&quot;Flat vs sharp minima&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Here’s the intuition why a flat minimum should generalize better, as originally articulated by &lt;a href=&quot;http://www.cs.toronto.edu/~fritz/absps/colt93.pdf&quot;&gt;Hinton and Camp 1993&lt;/a&gt;. Crudely speaking, suppose a flat minimum is one that occupies “volume” $\tau$ in the landscape. (The flatter the minimum, the higher $\tau$ is.)  Then the number of &lt;em&gt;distinct&lt;/em&gt; flat minima in the landscape is at most $S =\text{total volume}/\tau$. Thus one can number the flat minima from $1$ to $S$, implying that a flat minimum can be represented using $\log S$ bits.  The above-mentioned &lt;em&gt;basic theorem&lt;/em&gt; implies that flat minima generalize if the number of training samples $m$ exceeds $\log S$.&lt;/p&gt;

&lt;p&gt;PAC-Bayes approaches try to formalize the above intuition by defining a flat minimum as follows: it is a net $C$ such that adding appropriately-scaled gaussian noise to all its trainable parameters does not greatly affect the training error. This allows quantifying the “volume” above in terms of probability/measure (see 
&lt;a href=&quot;http://www.cs.princeton.edu/courses/archive/fall17/cos597A/lecnotes/generalize.pdf&quot;&gt;my lecture notes&lt;/a&gt; or &lt;a href=&quot;https://arxiv.org/abs/1703.11008&quot;&gt;Dziugaite-Roy&lt;/a&gt;) and yields some explicit estimates on sample complexity.  However, obtaining good quantitative estimates from this calculation has proved difficut, as seen in the bar graph earlier.&lt;/p&gt;

&lt;p&gt;We formalize “flat minimum” using noise stability of a slightly different form. Roughly speaking, it says that if we inject appropriately scaled gaussian noise at the output of some layer, then this noise gets attenuated as it propagates up to higher layers. (Here “top” direction refers to the output of the net.)  This is obviously related to notions like dropout, though it arises also in nets that are not trained with dropout. The following figure illustrates how noise injected at a certain layer of VGG19 (trained on CIFAR10) affects the higher layer. The y-axis denote the magnitude of the noise ($\ell_2$ norm) as a multiple of the vector being computed at the layer, and shows how a single noise vector quickly attenuates as it propagates up the layers.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/saddle_eff/attenuate.jpg&quot; width=&quot;65%&quot; alt=&quot;How noises attenuates as it travels up the layers of VGG.&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Clearly, computation of the trained net is highly resistant to noise. (This has obvious implications for biological neural nets…) 
Note that the training involved no explicit injection of noise (eg dropout). Of course, stochastic gradient descent &lt;em&gt;implicitly&lt;/em&gt; adds noise to the gradient, and it would be nice to investigate more rigorously if the noise stability arises from this or from some other source.&lt;/p&gt;

&lt;h2 id=&quot;noise-stability-and-compressibility-of-single-layer&quot;&gt;Noise stability and compressibility of single layer&lt;/h2&gt;

&lt;p&gt;To understand why noise-stable nets are compressible, let’s first understand noise stability for a single layer in the net, where we ignore the nonlinearity. Then this layer is just a linear transformation, i.e., matrix $M$.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/saddle_eff/alinear.png&quot; width=&quot;40%&quot; alt=&quot;matrix M describing a single layer&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;What does it mean that this matrix’s output is stable to noise? Suppose the vector at the previous layer is a unit vector $x$. This is the output of the lower layers on an actual sample, so $x$ can be thought of as the “signal” for the current layer.  The matrix converts $x$ into $Mx$. If we inject a noise vector $\eta$ of unit norm at $x$ then the output must become $M(x +\eta)$. We say $M$ is noise stable for input $x$ if such noising affects the output very little, which implies the norm of $Mx$ is much higher than that of $M \eta$. 
The former is at most $\sigma_{max}(M)$, the largest singular value of $M$. The latter is approximately 
$(\sum_i \sigma_i(M)^2)^{1/2}/\sqrt{h}$ where $\sigma_i(M)$ is the $i$th singular value of $M$ and $h$ is dimension of $Mx$. The reason is that gaussian noise divides itself evenly across all directions, with variance in each direction $1/h$. 
We conclude that:
&lt;script type=&quot;math/tex&quot;&gt;(\sigma_{max}(M))^2 \gg \frac{1}{h} \sum_i (\sigma_i(M)^2),&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;which implies that the matrix has an uneven distribution of singular values. Ratio of left side and right side is called the &lt;a href=&quot;https://nickhar.wordpress.com/2012/02/29/lecture-15-low-rank-approximation-of-matrices/&quot;&gt;&lt;em&gt;stable rank&lt;/em&gt;&lt;/a&gt; and is at most the linear algebraic rank. Furthermore, the above analysis suggests that the “signal” $x$ is &lt;em&gt;correlated&lt;/em&gt; with the singular directions corresponding to the higher singular values, which is at the root of the noise stability.&lt;/p&gt;

&lt;p&gt;Our experiments on VGG and GoogleNet reveal that the higher layers of deep nets—where most of the net’s parameters reside—do indeed exhibit a highly uneven distribution of singular values, and that the signal aligns more with the higher singular directions. The figure below describes layer 10 in VGG19 trained on CIFAR10.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/saddle_eff/aspectrumlayer10.png&quot; width=&quot;45%&quot; alt=&quot;distribution of singular values of matrix at layer 10 of VGG19&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;compressing-multilayer-net&quot;&gt;Compressing multilayer net&lt;/h2&gt;

&lt;p&gt;The above analysis of noise stability in terms of singular values cannot hold across multiple layers of a deep net, because the mapping becomes nonlinear, thus lacking a notion of singular values.  Noise stability is therefore formalized using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant&quot;&gt;Jacobian&lt;/a&gt; of this mapping, which is the matrix describing how the output reacts to tiny perturbations of the input. Noise stability says that this nonlinear mapping passes signal (i.e., the vector from previous layers) much more strongly than it does a noise vector.&lt;/p&gt;

&lt;p&gt;Our compression algorithm applies a randomized transformation to the matrix of each layer (aside: note the use of randomness, which fits in our “compressing with fixed string” framework) that relies on the low stable rank condition at each layer. This compression introduces error in the layer’s output, but the vector describing this error is “gaussian-like” due to the use of randomness in the compression. Thus this error gets attenuated by higher layers.&lt;/p&gt;

&lt;p&gt;Details can be found in the paper. All noise stability properties formalized there are later checked in the experiments section.&lt;/p&gt;

&lt;h2 id=&quot;simpler-proofs-of-existing-generalization-bounds&quot;&gt;Simpler proofs of existing generalization bounds&lt;/h2&gt;

&lt;p&gt;In the paper we also use our compression framework to give elementary (say, 1-page) proofs of the previous generalization bounds from the past year. For example, the paper of &lt;a href=&quot;https://openreview.net/forum?id=Skz_WfbCZ&quot;&gt;Neyshabur et al.&lt;/a&gt; shows the following is an upper bound on the generalization error where $A_i$ is the matrix describing the $i$th layer.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/saddle_eff/aexpression1.png&quot; width=&quot;50%&quot; alt=&quot;Expression for effective number of parameters in Neyshabur et al&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Comparing to the &lt;em&gt;basic theorem&lt;/em&gt;, we realize the numerator corresponds to the number of effective parameters. The second part of the expression is the sum of stable ranks of the layer matrices, and is a natural measure of complexity. The first part is product of spectral norms (= top singular value) of the layer matrices, which happens to be an upper bound on the Lipschitz constant of the entire network. (Lipschitz constant of a mapping $f$ in this context is a constant $L$ such that $f(x) \leq L c\dot |x|$.) 
The reason this is the Lipschitz constant is that if an input $x$ is presented at the bottom of the net, then each successive layer can multiply its norm by at most the top singular value, and the ReLU nonlinearity can only decrease norm since its only action is to zero out some entries.&lt;/p&gt;

&lt;p&gt;Having decoded the above expression, it is clear how to interpret it as an analysis of a (deterministic) compression of the net. Compress each layer by zero-ing out (in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Singular-value_decomposition&quot;&gt;SVD&lt;/a&gt;) singular values less than some threshold $t|A|$, which we hope turns it into a low rank matrix. (Recall that a matrix with rank $r$ can be expressed using $2nr$ parameters.)   A simple computation shows that the number of remaining singular values is at most the stable rank divided by $t^2$.  How do we set $t$? The truncation introduces error in the layer’s computation, which gets propagated through the higher layers and magnified at most by the Lipschitz constant. We want to make this propagated error small, which can be done by making $t$ inversely proportional to the Lipschitz constant.  This leads to the above bound on the number of effective parameters.&lt;/p&gt;

&lt;p&gt;This proof sketch also clarifies how our work improves upon the older works: they are also (implicitly) compressing the deep net, but their analysis of how much compression is possible is much more pessimistic because they assume the network transmits noise at peak efficiency given by the Lipschitz constant.&lt;/p&gt;

&lt;h2 id=&quot;extending-the-ideas-to-convolutional-nets&quot;&gt;Extending the ideas to convolutional nets&lt;/h2&gt;

&lt;p&gt;Convolutional nets could not be dealt with cleanly in the earlier papers. I must admit that handling convolution stumped us as too for a while. A layer in a convolutional net applies the same filter to all patches in that layer. This &lt;em&gt;weight sharing&lt;/em&gt; means that the full layer matrix already has a fairly compact representation, and it seems challenging to compress this further. However, in nets like VGG and GoogleNet, the higher layers use rather large filter matrices (i.e., they use a large number of channels), and one could hope to compress these individual filter matrices.&lt;/p&gt;

&lt;p&gt;Let’s discuss the two naive ideas. The first is to compress the filter independently in different patches. This unfortunately is not a compression at all, since  each  copy of the filter then comes with its own parameters. The second idea is to do a single compression of the filter and use the compressed copy in each patch. This messes up the error analysis because the errors introduced due to compression in the different copies are now correlated, whereas the analysis requires them to be more like gaussian.&lt;/p&gt;

&lt;p&gt;The idea we end up using is to compress the filters using $k$-wise independence (an idea from &lt;a href=&quot;https://en.wikipedia.org/wiki/K-independent_hashing&quot;&gt;theory of hashing schemes&lt;/a&gt;), where $k$ is roughly logarithmic in the number of training samples.&lt;/p&gt;

&lt;h2 id=&quot;concluding-thoughts&quot;&gt;Concluding thoughts&lt;/h2&gt;

&lt;p&gt;While generalization theory can seem merely academic at times —since in practice held-out data establishes generalizaton— I hope you see from the above account that understanding generalization can give some interesting insights into what is going on in deep net training. Insights about noise stability of trained deep nets have obvious interest for study of biological neural nets. (See also the classic &lt;a href=&quot;http://fab.cba.mit.edu/classes/862.16/notes/computation/vonNeumann-1956.pdf&quot;&gt;von Neumann ideas&lt;/a&gt; on noise resilient computation.)&lt;/p&gt;

&lt;p&gt;At the same time, I suspect that compressibility is only one part of the generalization mystery, and that we are still missing some big idea. I don’t see how to use the above ideas to demonstrate that the effective number of parameters in VGG19 is as low as $50k$, as seems to be the case. I suspect doing so will force us to understand the structure of the data (in this case, real-life images) which the above analysis mostly ignores. The only property of data used is that the deep net aligns itself better with data than with noise.&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Feb 2018 08:00:00 -0800</pubDate>
        <link>http://localhost:4000/2018/02/17/generalization2/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/17/generalization2/</guid>
      </item>
     
    
  </channel>
</rss>
